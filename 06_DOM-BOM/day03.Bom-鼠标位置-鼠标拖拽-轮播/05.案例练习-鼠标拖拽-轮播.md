+ 获取dom对象
+ 事件类型
+ 节点操作
+ DOM版本 事件流  事件委派
+ 定时器
+ 案例练习
  + 拖拽
  + 轮播图

## 1. 获取样式

### 1.1 js获取style中的样式

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <style type="text/css">
            #box {
                position: absolute;
                left: 100px;
                top: 100px;
                width: 200px;
                height: 200px;
                background-color: red;
            }
        </style>
    </head>
    <body>
        <div id="box">
        </div>
        <script>
            var d = document.getElementById('box');
            console.log(d.style.width);
            console.log(d.style.backgroundColor);
        </script>
    </body>
</html>
```

### 1.2 Client系列   只读

+ **clientWidth**  拿的是盒子content内容 + padding的宽 (常用)
+ **clientHeight** 拿的是盒子content内容 + padding的高 (常用)
+ **clientLeft**     拿的是盒子左边框大小
+ **clientTop**      拿的是盒子上边框大小

### 1.3 Offset系列    只读 (常用, 重要)

+ **offsetWidth**  
  + 拿的是盒子内容content + padding + border的宽
+ **offsetHeight** 
  + 拿的是盒子内容content + padding + border的高
+ **offsetLeft**      
  + 拿的是元素的偏移量：可以认为就是拿的绝对定位left值
  + <u>切记如果进行offsetLeft的值进行加法运算不允许添加px</u>
+ **offsetTop**       
  + 拿的是元素的偏移量：可以认为就是拿的绝对定位top值

### 1.4 Scroll系列

+ **scrollWidth   只读**
  + 当内容比盒子小的时候，拿的是盒子的clientWidth
  + 当内容比盒子大的时候，拿的是内容的offsetWidth + 盒子的一侧内边距
  + document.documentElement.scrollWidth   
+ **scrollHeight  只读**
  + 当内容比盒子小的时候，拿的是盒子的clientHeight
  + 当内容比盒子大的时候，拿的是内容的offsetHeight + 盒子的一侧内边距
  + document.documentElement.scrollHeight  
+ **scrollTop可读可写 (重要)**
  + 拿的是盒子内容向上滚动的距离
  + document.documentElement.scrollTop
+ **scrollLeft可读可写 (重要)**
  + 拿的是盒子内容向左滚动的距离
  + document.documentElement.scrollLeft

### 1.5 总结

1. 元素的大小：宽和高的获取：以后我们拿元素的宽和高，先看元素有没有边框，如果没有边框，那么
   
   clientWidth和offsetWidth是一样的，如果有边框，看你需要不，需要的话就用offsetWidth 
   
   不需要就用clientWidth; scrollWidth几乎不用

2. 元素的位置（偏移量）的获取：以后需要获取元素的位置直接通过offsetLeft和offsetTop去获取，但是注意相对的参照元素是谁；（和绝对定位参照类似）

3. 视口宽高求法（固定的）
   
   1. document.documentElement.clientWidth
   2. document.documentElement.clientHeight

### 1.6 案例

+ 导航栏跟随

```html
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>09_案例练习-导航栏跟随</title>
        <style>
            * {
                margin: 0;
                padding: 0;
            }
            div {
                position: absolute;
                width: 1366px;
                height: 160px;
                background-color: #ccc;
                text-align: center;
                line-height: 160px;

            }

            input {
                width: 700px;
                height: 40px;
                border: 1px solid orangered;
                border-radius: 20px;
                outline: none;
            }
        </style>
    </head>
    <body style="height: 3000px;">
        <div>
            <input type="text">
        </div>

        <script>
            // 如果滚动条滚动了 一个视口的高度 那么就将div固定在最上面

            var div = document.querySelector('div');


            document.onscroll = function(){
                // 滚动的距离
                var scroll_dis = document.documentElement.scrollTop;

                // 视口的高度
                // var vp_height = document.documentElement.clientHeight;

                if(scroll_dis >= 100){
                    div.style.position = 'fixed';
                }else {
                    div.style.position = 'static';
                }

            }

        </script>
    </body>
</html>
```

+ 盒子来回移动

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }

            #box{
                position: absolute;
                left: 0;
                top: 0;
                width: 100px;
                height: 80px;
                background-color: red;
            }
        </style>
    </head>
    <body>
        <div id="box"></div>

        <script type="text/javascript">
            //求出盒子最新的位置，设置给盒子的left 就能让盒子动
            // 盒子的新位置  = 盒子的原始位置  + 盒子要移动的距离差

            var box = document.getElementById('box');
//            setTimeout(function(){
//                //第一步：拿到盒子原来的位置
//                var eleX = box.offsetLeft;
//                //第二步：求出现在准备要走的位置
//                var lastX = eleX + 50;
//                //第三步：把算出来的位置设置给box
//                box.style.left = lastX + 'px';
//                
//            },3000)

            var step = 3;
            setInterval(function(){
                //第一步：拿到盒子原来的位置
                var eleX = box.offsetLeft;
                //第二步：求出现在准备要走的位置
                var lastX = eleX + step;

                //在判定临界值，当达到左右临界的时候，往相反方向去走
                if(lastX > document.documentElement.clientWidth - box.offsetWidth){
                    lastX = document.documentElement.clientWidth - box.offsetWidth;
                    step = -3;
                }else if(lastX < 0){
                    lastX = 0;
                    step = 3;
                }


                //第三步：把算出来的位置设置给box
                box.style.left = lastX + 'px';
            },16)    
        </script>
    </body>
</html>
```

## 2. 系统滚动条的控制

html和body这两个元素overflow的scroll属性，控制着系统的滚动条，系统的滚动条有两个，一个是body身上的，一个是document身上的。我们平时看到的那个滚动条是document身上的。如果我们想要控制系统滚动条哪个显示哪个关闭分以下情况：

+ 单独的给body或者html 设置overflow:scroll  滚动条打开的全部都是document的
+ 如果两个元素同时设置overflow属性，body设置的是scroll,html设置是hidden,那么document的滚动条被关闭，body身上的滚动条会打开，相反，body身上被关闭，document身上的被打开
+ **如果两个元素同时设置overflow:hidden；那么系统的两个滚动条全部被关闭**
+ 如果两个都设置overflow:scroll,那么html会打开document身上的，而body会打开自己身上的滚动条

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }

           /* html{
                width: 500px;
                height: 500px;
                border: 10px solid black;
                overflow: scroll;
            }

            body{
                width: 300px;
                height: 300000px;
                border: 10px solid blue;
                overflow: scroll;
            } */

            // 企业级开发中常用写法，记住这一写法，其他的写法了解即可
             html,body{
                 height:100%;    
                 overflow:hidden;             
             }

        </style>
    </head>
    <body>
        <div id="box">
            <div id="box1"></div>
        </div>
    </body>
</html>
```

## 3. 鼠标拖拽基础

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }

            #box{
                position: absolute;
                left: 0;
                top: 0;
                width: 150px;
                height: 80px;
                background-color: red;
            }
        </style>
    </head>
    <body>
        <div id="box"></div>

        <script type="text/javascript">
            window.onload = function(){
                var box = document.getElementById('box');

                box.onmousedown = function(e){
                    e = e || window.event;
                    //按下的时候获取元素的初始位置和鼠标的初始位置
                    var eleX = box.offsetLeft;
                    var eleY = box.offsetTop;

                    var startX = e.clientX;
                    var startY = e.clientY;

                    box.onmousemove = function(e){
                        e = e || window.event;
                        //可以获取鼠标的结束位置
                        var endX = e.clientX;
                        var endY = e.clientY;
                        //求出鼠标的距离差
                        var disX = endX - startX;
                        var disY = endY - startY;
                        //求出元素移动的最终位置  =  元素的初始位置  + 鼠标的距离差
                        var lastX = eleX + disX;
                        var lastY = eleY + disY;
                        //把求出来的最终位置设置给元素
                        box.style.left = lastX + 'px';
                        box.style.top = lastY + 'px';
                    };

                    // 给鼠标移动和鼠标抬起事件解绑，否则松开鼠标时还在拖拽
                    box.onmouseup = function(){
                        box.onmousemove = box.onmouseup = null;
                    }

                }

            }
        </script>
    </body>
</html>
```

基础拖拽问题：

+ 鼠标拖动过快，会跑出元素，元素就不动

​       因为计算机跟不上你的速度，跑出盒子，盒子不动，因为事件添加在盒子身上，跑出去后事件就不在盒子身上触发了。包括在外部鼠标抬起，也是解绑不了盒子上的事件的，因为鼠标抬起也是在盒子身上添加的；解决：移动事件和抬起事件，最好添加给document

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }

            #box{
                position: absolute;
                left: 0;
                top: 0;
                width: 150px;
                height: 80px;
                background-color: red;
            }
        </style>
    </head>
    <body>
        <div id="box"></div>

        <script type="text/javascript">
            window.onload = function(){
                var box = document.getElementById('box');

                box.onmousedown = function(e){
                    e = e || window.event;
                    //按下的时候获取元素的初始位置和鼠标的初始位置
                    var eleX = box.offsetLeft;
                    var eleY = box.offsetTop;

                    var startX = e.clientX;
                    var startY = e.clientY;

                    document.onmousemove = function(e){
                        e = e || window.event;
                        //可以获取鼠标的结束位置
                        var endX = e.clientX;
                        var endY = e.clientY;
                        //求出鼠标的距离差
                        var disX = endX - startX;
                        var disY = endY - startY;
                        //求出元素移动的最终位置  =  元素的初始位置  + 鼠标的距离差
                        var lastX = eleX + disX;
                        var lastY = eleY + disY;
                        //把求出来的最终位置设置给元素
                        box.style.left = lastX + 'px';
                        box.style.top = lastY + 'px';
                    };

                    document.onmouseup = function(){
                        document.onmousemove = document.onmouseup = null;
                    }                
                }    
            }
        </script>
    </body>
</html>
```

+ 在盒子当中写上文字，拖拽先选中文字，再拖拽，文字跟着走，盒子不动，放手盒子会瞬间到放手的位置
  
  因为浏览器有默认行为，拖拽文字就是一个默认行为。解决：取消浏览器的默认行为
  
  取消浏览器默认行为根据事件添加方式不同而不同
  
  - dom0事件，那么在事件回调函数里的最后位置写上return false；
  - dom2事件, 在事件回调当中添加e.preventDefault()；

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }

            #box{
                position: absolute;
                left: 0;
                top: 0;
                width: 150px;
                height: 80px;
                background-color: red;
            }
        </style>
    </head>
    <body>
        <div id="box">张三</div>

        <script type="text/javascript">
            window.onload = function(){
                var box = document.getElementById('box');

                box.onmousedown = function(e){
                    e = e || window.event;
                    //按下的时候获取元素的初始位置和鼠标的初始位置
                    var eleX = box.offsetLeft;
                    var eleY = box.offsetTop;

                    var startX = e.clientX;
                    var startY = e.clientY;

                    document.onmousemove = function(e){
                        e = e || window.event;
                        //可以获取鼠标的结束位置
                        var endX = e.clientX;
                        var endY = e.clientY;
                        //求出鼠标的距离差
                        var disX = endX - startX;
                        var disY = endY - startY;
                        //求出元素移动的最终位置  =  元素的初始位置  + 鼠标的距离差
                        var lastX = eleX + disX;
                        var lastY = eleY + disY;
                        //把求出来的最终位置设置给元素
                        box.style.left = lastX + 'px';
                        box.style.top = lastY + 'px';
                    };                
                    document.onmouseup = function(){
                        box.onmousemove = box.onmouseup = null;
                    }
                    return false;
                }    
            }
        </script>
    </body>
</html>
```

## 4. 鼠标拖拽添加临界值(边界问题)

```js
window.onload = function(){
                var box = document.getElementById('box');
                box.onmousedown = function(e){
                    e = e || window.event;
                    //按下的时候获取元素的初始位置和鼠标的初始位置
                    var eleX = box.offsetLeft;
                    var eleY = box.offsetTop;
                    var startX = e.clientX;
                    var startY = e.clientY;
                    //全局捕获
                    box.setCapture&&box.setCapture();//只有低版本浏览器才会用到全局捕获
                    document.onmousemove = function(e){
                        e = e || window.event;
                        //可以获取鼠标的结束位置
                        var endX = e.clientX;
                        var endY = e.clientY;
                        //求出鼠标的距离差
                        var disX = endX - startX;
                        var disY = endY - startY;
                        //求出元素移动的最终位置  =  元素的初始位置  + 鼠标的距离差
                        var lastX = eleX + disX;
                        var lastY = eleY + disY;


                        //添加临界值，左右范围
                        if(lastX > document.documentElement.clientWidth - box.offsetWidth){
                            lastX = document.documentElement.clientWidth - box.offsetWidth
                        }else if(lastX < 0){
                            lastX = 0;
                        }


                        //添加临界值，上下范围
                        if(lastY > document.documentElement.clientHeight - box.offsetHeight){
                            lastY = document.documentElement.clientHeight - box.offsetHeight
                        }else if(lastY < 0){
                            lastY = 0;
                        }

                        //把求出来的最终位置设置给元素
                        box.style.left = lastX + 'px';
                        box.style.top = lastY + 'px';
                    };
                    document.onmouseup = function(){
                        document.onmousemove = document.onmouseup = null;
                        box.releaseCapture&&box.releaseCapture();//低版本浏览器释放全局捕获

                    }
                    return false;
                }
            }
```

## 5. 鼠标拖拽吸附效果

```js
window.onload = function(){
                var box = document.getElementById('box');
                box.onmousedown = function(e){
                    e = e || window.event;
                    //按下的时候获取元素的初始位置和鼠标的初始位置
                    var eleX = box.offsetLeft;
                    var eleY = box.offsetTop;
                    var startX = e.clientX;
                    var startY = e.clientY;
                    //全局捕获
                    box.setCapture&&box.setCapture();//只有低版本浏览器才会用到全局捕获
                    document.onmousemove = function(e){
                        e = e || window.event;
                        //可以获取鼠标的结束位置
                        var endX = e.clientX;
                        var endY = e.clientY;
                        //求出鼠标的距离差
                        var disX = endX - startX;
                        var disY = endY - startY;
                        //求出元素移动的最终位置  =  元素的初始位置  + 鼠标的距离差
                        var lastX = eleX + disX;
                        var lastY = eleY + disY;


                        //添加临界值，左右范围
                        // 吸附效果
                        if(lastX > document.documentElement.clientWidth - box.offsetWidth - 50){
                            lastX = document.documentElement.clientWidth - box.offsetWidth
                        }else if(lastX < 50){
                            lastX = 0;
                        }


                        //添加临界值，上下范围
                        //吸附效果
                        if(lastY > document.documentElement.clientHeight - box.offsetHeight - 50){
                            lastY = document.documentElement.clientHeight - box.offsetHeight
                        }else if(lastY < 50){
                            lastY = 0;
                        }

                        //把求出来的最终位置设置给元素
                        box.style.left = lastX + 'px';
                        box.style.top = lastY + 'px';
                    };
                    document.onmouseup = function(){
                        document.onmousemove = document.onmouseup = null;
                        box.releaseCapture&&box.releaseCapture();//低版本浏览器释放全局捕获

                    }
                    return false;
                }
            }
```

## 6. 添加碰撞效果

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }

            #box{
                position: absolute;
                left: 0;
                top: 0;
                width: 150px;
                height: 80px;
                background-color: red;
            }

            img{
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                right: 0;
                margin: auto;
                width: 200px;
                height: 100px;
            }
        </style>
    </head>
    <body>
        <div id="box">老马</div>
        <img src="img/1.jpg" alt="" />
        <script type="text/javascript">
            window.onload = function(){
                var box = document.getElementById('box');
                var imgNode = document.querySelector('img');
                box.onmousedown = function(e){
                    e = e || window.event;
                    //按下的时候获取元素的初始位置和鼠标的初始位置
                    var eleX = box.offsetLeft;
                    var eleY = box.offsetTop;
                    var startX = e.clientX;
                    var startY = e.clientY;
                    //全局捕获
                    box.setCapture&&box.setCapture();//只有低版本浏览器才会用到全局捕获
                    document.onmousemove = function(e){
                        e = e || window.event;
                        //可以获取鼠标的结束位置
                        var endX = e.clientX;
                        var endY = e.clientY;
                        //求出鼠标的距离差
                        var disX = endX - startX;
                        var disY = endY - startY;
                        //求出元素移动的最终位置  =  元素的初始位置  + 鼠标的距离差
                        var lastX = eleX + disX;
                        var lastY = eleY + disY;


                        //添加临界值
                        if(lastX > document.documentElement.clientWidth - box.offsetWidth - 50){
                            lastX = document.documentElement.clientWidth - box.offsetWidth
                        }else if(lastX < 50){
                            lastX = 0;
                        }

                        if(lastY > document.documentElement.clientHeight - box.offsetHeight - 50){
                            lastY = document.documentElement.clientHeight - box.offsetHeight
                        }else if(lastY < 50){
                            lastY = 0;
                        }

                        //把求出来的最终位置设置给元素
                        box.style.left = lastX + 'px';
                        box.style.top = lastY + 'px';

                        //设置元素位置之后，然后判断是否发生碰撞
                        var boxL = lastX + box.offsetWidth;//求盒子在图片左侧的位置+自身宽度
                        var imgL = imgNode.getBoundingClientRect().left;//专门求元素相对视口的位置

                        var boxT = lastY + box.offsetHeight;
                        var imgT = imgNode.getBoundingClientRect().top;

                        var boxR = lastX;
                        var imgR = imgNode.getBoundingClientRect().left + imgNode.offsetWidth;

                        var boxB = lastY;
                        var imgB = imgNode.getBoundingClientRect().top + imgNode.offsetHeight;

                        if(boxL < imgL || boxT < imgT || boxR > imgR  || boxB > imgB){
                            //碰不到
                            imgNode.src = 'img/1.jpg';
                        }else{
                            //碰到了
                            imgNode.src = 'img/2.jpg';
                        }

                    };
                    document.onmouseup = function(){
                        document.onmousemove = document.onmouseup = null;
                        box.releaseCapture&&box.releaseCapture();//低版本浏览器释放全局捕获

                    }
                    return false;
                }
            }
        </script>
    </body>
</html>
```

## 7. 添加自定义滚动条

我们的页面架构首先要清楚

​      页面的最外层是document,紧接着是初始包含块，html， body，其次是我们的元素，我们禁止了系统的滚动条，（因为各大浏览器的系统滚动条风格不一，有可能会影响我们的页面布局），所以在body当中我们一般会有最外的一个盒子模拟body区域，在这个盒子的右侧会定位一个盒子模拟滚动条

+ 原始页面

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }

            html,body{
                height: 100%;
                overflow: hidden;
            }

             /* 造一个和body等宽等高的盒子 */
            #wrap{
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }

            /* height:100% 让滑槽和整个浏览器的视口的高度一样高 */
            #wrap .scrollBar{
                position: absolute;
                right: 0;
                top: 0;
                width: 30px;
                height: 100%;
                background-color: hotpink;
                border-left: 1px solid greenyellow;
                border-right: 1px solid greenyellow;
            }

            #wrap .scrollBar .scrollIn{
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                top: 0;
                width: 26px;
                height: 100px;
                background-color: deepskyblue;
            }
        </style>
    </head>
    <body>
        <div id="wrap"> 
            <!-- 滑槽 -->
            <div class="scrollBar">
                 <!-- 滑块 -->
                <div class="scrollIn"></div>
            </div>
        </div>
        <script type="text/javascript">
        </script>
    </body>
</html>
```

+ js实现

```js
    <script type="text/javascript">
            //让滚动条滑块先动起来
            window.onload = function(){
                var scrollIn = document.querySelector('#wrap .scrollBar .scrollIn');
                scrollIn.onmousedown = function(e){
                    // 如果e存在(即现代浏览器传递了事件对象),就使用e
                    // 如果e不存在(即在旧IE中),则使用window.event
                    // 这种写法主要用于兼容非常旧的浏览器。在现代Web开发中,由于IE已经被淘汰,这种兼容性处理通常不再需要
                    e = e || window.event;
                    //按下的时候获取元素的初始位置和鼠标的初始位置
                    var eleY = scrollIn.offsetTop;
                    var startY = e.clientY;
                    //全局捕获
                    scrollIn.setCapture&&scrollIn.setCapture();//只有低版本浏览器才会用到全局捕获
                    document.onmousemove = function(e){
                        e = e || window.event;
                        //可以获取鼠标的结束位置
                        var endY = e.clientY;
                        //求出鼠标的距离差
                        var disY = endY - startY;
                        //求出元素移动的最终位置  =  元素的初始位置  + 鼠标的距离差
                        var lastY = eleY + disY;

                        //添加临界值
                        if(lastY > document.documentElement.clientHeight -scrollIn.offsetHeight){
                            lastY = document.documentElement.clientHeight - scrollIn.offsetHeight
                        }else if(lastY < 0){
                            lastY = 0;
                        }
                        //把求出来的最终位置设置给元素
                        scrollIn.style.top = lastY + 'px';
                    };
                    document.onmouseup = function(){
                        document.onmousemove = document.onmouseup = null;
                        scrollIn.releaseCapture&&scrollIn.releaseCapture();//低版本浏览器释放全局捕获
                    }
    
                    return false;
                }
            }
        </script>
```

## 8. 滚动条带内容移动

+ 设置内容

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }

            html,body{
                height: 100%;
                overflow: hidden;
            }

            #wrap{
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }

            #wrap .content{
                position: absolute;
                left: 0;
                top: 0;
            }


            #wrap .scrollBar{
                position: absolute;
                right: 0;
                top: 0;
                width: 30px;
                height: 100%;
                background-color: hotpink;
                border-left: 1px solid greenyellow;
                border-right: 1px solid greenyellow;
            }

            #wrap .scrollBar .scrollIn{
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                top: 0;
                width: 26px;
                height: 100px;
                background-color: deepskyblue;
            }
        </style>
    </head>
    <body>
        <div id="wrap">

            <div class="content"></div>


            <div class="scrollBar">
                <div class="scrollIn"></div>
            </div>
        </div>
        <script type="text/javascript">
            //让滚动条滑块先动起来
            window.onload = function(){
                var scrollIn = document.querySelector('#wrap .scrollBar .scrollIn');
                var content = document.querySelector('#wrap .content');

                //模拟内容，给网页上写点内容
                for(var i = 0; i < 200; i++){
                    content.innerHTML += i + '<br>';
//                    content.innerHTML = content.innerHTML +  i + '<br>'
                }

                scrollIn.onmousedown = function(e){
                    e = e || window.event;
                    //按下的时候获取元素的初始位置和鼠标的初始位置
                    var eleY = scrollIn.offsetTop;
                    var startY = e.clientY;
                    //全局捕获
                    scrollIn.setCapture&&scrollIn.setCapture();//只有低版本浏览器才会用到全局捕获
                    document.onmousemove = function(e){
                        e = e || window.event;
                        //可以获取鼠标的结束位置
                        var endY = e.clientY;
                        //求出鼠标的距离差
                        var disY = endY - startY;
                        //求出元素移动的最终位置  =  元素的初始位置  + 鼠标的距离差
                        var lastY = eleY + disY;

                        //添加临界值
                        if(lastY > document.documentElement.clientHeight - scrollIn.offsetHeight){
                            lastY = document.documentElement.clientHeight - scrollIn.offsetHeight
                        }else if(lastY < 0){
                            lastY = 0;
                        }
                        //把求出来的最终位置设置给元素
                        scrollIn.style.top = lastY + 'px';
                    };
                    document.onmouseup = function(){
                        document.onmousemove = document.onmouseup = null;
                        scrollIn.releaseCapture&&scrollIn.releaseCapture();//低版本浏览器释放全局捕获
                    }
                    return false;
                }
            }
        </script>
    </body>
</html>    
```

+ 滚动条长度设置（**注意样式中原本定死的滚动条**）
  
  <font color='bronze'>**自定义滚动条的万能比例：**</font>
  <font color='bronze'>**滑块的高度 / 滑槽的高度 = 滑槽的高度 / 内容的高度 = 滑块滚动距离 / 内容的滚动距离**</font>

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }

            html,body{
                height: 100%;
                overflow: hidden;
            }

            #wrap{
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }

            #wrap .content{
                position: absolute;
                left: 0;
                top: 0;
            }


            #wrap .scrollBar{
                position: absolute;
                right: 0;
                top: 0;
                width: 30px;
                height: 100%;
                background-color: hotpink;
                border-left: 1px solid greenyellow;
                border-right: 1px solid greenyellow;
            }

            #wrap .scrollBar .scrollIn{
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                top: 0;
                width: 26px;
                /*height: 100px;*/
                background-color: deepskyblue;
            }
        </style>
    </head>
    <body>
        <div id="wrap">

            <div class="content"></div>


            <div class="scrollBar">
                <div class="scrollIn"></div>
            </div>
        </div>
        <script type="text/javascript">
            //让滚动条滑块先动起来
            window.onload = function(){
                var scrollIn = document.querySelector('#wrap .scrollBar .scrollIn');
                var content = document.querySelector('#wrap .content');


                //模拟内容，给网页上写点内容
                for(var i = 0; i < 100; i++){
                    content.innerHTML += i + '<br>';
//                    content.innerHTML = content.innerHTML +  i + '<br>'
                }

                //设置滑块的高度
//                自定义滚动条的万能比例：
//                滑块的高度 / 滑槽的高度 = 滑槽的高度 / 内容的高度 = 滑块滚动距离 / 内容的滚动距离 
                var scale = document.documentElement.clientHeight / content.offsetHeight;
                var scrollHeight = document.documentElement.clientHeight * scale;
                scrollIn.style.height = scrollHeight + 'px';

                scrollIn.onmousedown = function(e){
                    e = e || window.event;
                    //按下的时候获取元素的初始位置和鼠标的初始位置
                    var eleY = scrollIn.offsetTop;
                    var startY = e.clientY;
                    //全局捕获
                    scrollIn.setCapture&&scrollIn.setCapture();//只有低版本浏览器才会用到全局捕获
                    document.onmousemove = function(e){
                        e = e || window.event;
                        //可以获取鼠标的结束位置
                        var endY = e.clientY;
                        //求出鼠标的距离差
                        var disY = endY - startY;
                        //求出元素移动的最终位置  =  元素的初始位置  + 鼠标的距离差
                        var lastY = eleY + disY;

                        //添加临界值
                        if(lastY > document.documentElement.clientHeight - scrollIn.offsetHeight){
                            lastY = document.documentElement.clientHeight - scrollIn.offsetHeight
                        }else if(lastY < 0){
                            lastY = 0;
                        }
                        //把求出来的最终位置设置给元素
                        scrollIn.style.top = lastY + 'px';
                    };
                    document.onmouseup = function(){
                        document.onmousemove = document.onmouseup = null;
                        scrollIn.releaseCapture&&scrollIn.releaseCapture();//低版本浏览器释放全局捕获
                    }
                    return false;
                }
            }
        </script>
    </body>
</html>
```

+ 滚动条和内容联动（注意方向）

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }

            html,body{
                height: 100%;
                overflow: hidden;
            }

            #wrap{
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }

            #wrap .content{
                position: absolute;
                left: 0;
                top: 0;
            }


            #wrap .scrollBar{
                position: absolute;
                right: 0;
                top: 0;
                width: 30px;
                height: 100%;
                background-color: hotpink;
                border-left: 1px solid greenyellow;
                border-right: 1px solid greenyellow;
            }

            #wrap .scrollBar .scrollIn{
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                top: 0;
                width: 26px;
                /*height: 100px;*/
                background-color: deepskyblue;
            }
        </style>
    </head>
    <body>
        <div id="wrap">

            <div class="content"></div>


            <div class="scrollBar">
                <div class="scrollIn"></div>
            </div>
        </div>
        <script type="text/javascript">
            //让滚动条滑块先动起来
            window.onload = function(){
                var scrollIn = document.querySelector('#wrap .scrollBar .scrollIn');
                var content = document.querySelector('#wrap .content');


                //模拟内容，给网页上写点内容
                for(var i = 0; i < 200; i++){
                    content.innerHTML += i + '<br>';
//                    content.innerHTML = content.innerHTML +  i + '<br>'
                }

                //设置滑块的高度
//                自定义滚动条的万能比例：
//                滑块的高度 / 滑槽的高度 = 滑槽的高度 / 内容的高度 = 滑块滚动距离 / 内容的滚动距离 
                var scale = document.documentElement.clientHeight / content.offsetHeight;
                var scrollHeight = document.documentElement.clientHeight * scale;
                scrollIn.style.height = scrollHeight + 'px';

                scrollIn.onmousedown = function(e){
                    e = e || window.event;
                    //按下的时候获取元素的初始位置和鼠标的初始位置
                    var eleY = scrollIn.offsetTop;
                    var startY = e.clientY;
                    //全局捕获
                    scrollIn.setCapture&&scrollIn.setCapture();//只有低版本浏览器才会用到全局捕获
                    document.onmousemove = function(e){
                        e = e || window.event;
                        //可以获取鼠标的结束位置
                        var endY = e.clientY;
                        //求出鼠标的距离差
                        var disY = endY - startY;
                        //求出元素移动的最终位置  =  元素的初始位置  + 鼠标的距离差
                        var lastY = eleY + disY;

                        //添加临界值
                        if(lastY > document.documentElement.clientHeight - scrollIn.offsetHeight){
                            lastY = document.documentElement.clientHeight - scrollIn.offsetHeight
                        }else if(lastY < 0){
                            lastY = 0;
                        }
                        //把求出来的最终位置设置给元素
                        scrollIn.style.top = lastY + 'px';
                        //添加内容滚动逻辑
//                        滑槽的高度 / 内容的高度 = 滑块滚动距离 / 内容的滚动距离 
                        var contentDis = lastY / scale;
                        content.style.top = -contentDis + 'px';


                    };
                    document.onmouseup = function(){
                        document.onmousemove = document.onmouseup = null;
                        scrollIn.releaseCapture&&scrollIn.releaseCapture();//低版本浏览器释放全局捕获
                    }
                    return false;
                }
            }
        </script>
    </body>
</html>
```

## 9. 滚轮事件基础

区分上下

+ ie/chrome : mousewheel(dom2的标准模式)/onmousewheel（dom0）

​                 event.wheelDelta

​                      上：120

​                      下：-120

​              上和下指的是滚轮的方向

+ firefox: DOMMouseScroll(dom2的标准模式) 没有DOM0事件的

​                 event.detail

​                      上：-3

​                      下：3

​                上和下指的是滚轮的方向

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }
            #box{
                width: 300px;
                height: 300px;
                background-color: red;
            }
        </style>
    </head>
    <body>
        <div id="box"></div>


        <script type="text/javascript">
            window.onload = function(){
                var box = document.getElementById('box');
                //IE/CHROME
                box.addEventListener('mousewheel',scrollMove);
                //fireFox
                box.addEventListener('DOMMouseScroll',scrollMove);

                //与其讲滚轮事件不如说在讲怎么区分滚轮是往下还是往上
                //兼容性去处理回调函数
                var flag = true;
                function scrollMove(e){
                    e = e || window.event;
                    if(e.wheelDelta){
                        //ie或者chrome
                        if(e.wheelDelta > 0){
                            //往上
                            flag = true;
                        }else{
                            //往下
                            flag = false;
                        }

                    }else if(e.detail){
                        //火狐
                        if(e.detail > 0){
                            //往下
                            flag = false;
                        }else{
                            //往上
                            flag = true;
                        }
                    }
                    if(flag){
                        //不管什么浏览器，一定是往上滚的
                        box.style.height = box.offsetHeight - 10 + 'px';

                    }else{
                        //不管什么浏览器，一定是往下滚的
                        box.style.height = box.offsetHeight + 10 + 'px';
                    }
                }
            }
        </script>
    </body>
</html>
```

## 10. 自定义滚动条添加滚轮事件

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }

            html,body{
                height: 100%;
                overflow: hidden;
            }

            #wrap{
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }

            #wrap .content{
                position: absolute;
                left: 0;
                top: 0;
            }


            #wrap .scrollBar{
                position: absolute;
                right: 0;
                top: 0;
                width: 30px;
                height: 100%;
                background-color: hotpink;
                border-left: 1px solid greenyellow;
                border-right: 1px solid greenyellow;
            }

            #wrap .scrollBar .scrollIn{
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                top: 0;
                width: 26px;
                /*height: 100px;*/
                background-color: deepskyblue;
            }
        </style>
    </head>
    <body>
        <div id="wrap">

            <div class="content"></div>


            <div class="scrollBar">
                <div class="scrollIn"></div>
            </div>
        </div>
        <script type="text/javascript">
            //让滚动条滑块先动起来
            window.onload = function() {
                var scrollIn = document.querySelector('#wrap .scrollBar .scrollIn');
                var content = document.querySelector('#wrap .content');


                //模拟内容，给网页上写点内容
                for (var i = 0; i < 200; i++) {
                    content.innerHTML += i + '<br>';
                  //content.innerHTML = content.innerHTML +  i + '<br>'
                }

                //设置滑块的高度
                //                自定义滚动条的万能比例：
                //                滑块的高度 / 滑槽的高度 = 滑槽的高度 / 内容的高度 = 滑块滚动距离 / 内容的滚动距离 
                var scale = document.documentElement.clientHeight / content.offsetHeight;
                var scrollHeight = document.documentElement.clientHeight * scale;
                scrollIn.style.height = scrollHeight + 'px';


                //拖拽滑块相关的
                scrollIn.onmousedown = function(e) {
                    e = e || window.event;
                    //按下的时候获取元素的初始位置和鼠标的初始位置
                    var eleY = scrollIn.offsetTop;
                    var startY = e.clientY;
                    //全局捕获
                    scrollIn.setCapture && scrollIn.setCapture(); //只有低版本浏览器才会用到全局捕获
                    document.onmousemove = function(e) {
                        e = e || window.event;
                        //可以获取鼠标的结束位置
                        var endY = e.clientY;
                        //求出鼠标的距离差
                        var disY = endY - startY;
                        //求出元素移动的最终位置  =  元素的初始位置  + 鼠标的距离差
                        var lastY = eleY + disY;

                        //添加临界值
                        if (lastY > document.documentElement.clientHeight - scrollIn.offsetHeight) {
                            lastY = document.documentElement.clientHeight - scrollIn.offsetHeight
                        } else if (lastY < 0) {
                            lastY = 0;
                        }
                        //把求出来的最终位置设置给元素
                        scrollIn.style.top = lastY + 'px';
                        //添加内容滚动逻辑
                        //滑槽的高度 / 内容的高度 = 滑块滚动距离 / 内容的滚动距离 
                        var contentDis = lastY / scale;
                        content.style.top = -contentDis + 'px';


                    };
                    document.onmouseup = function() {
                        document.onmousemove = document.onmouseup = null;
                        scrollIn.releaseCapture && scrollIn.releaseCapture(); //低版本浏览器释放全局捕获
                    }
                    return false;
                }

                //滚动滚轮相关的
                //IE/CHROME
                document.addEventListener('mousewheel', scrollMove);
                //fireFox
                document.addEventListener('DOMMouseScroll', scrollMove);
                //与其讲滚轮事件不如说在讲怎么区分滚轮是往下还是往上
                //兼容性去处理回调函数
                var flag = true;

                function scrollMove(e) {
                    e = e || window.event;
                    if (e.wheelDelta) {
                        //ie或者chrome
                        if (e.wheelDelta > 0) {
                            //往上
                            flag = true;
                        } else {
                            //往下
                            flag = false;
                        }

                    } else if (e.detail) {
                        //火狐
                        if (e.detail > 0) {
                            //往下
                            flag = false;
                        } else {
                            //往上
                            flag = true;
                        }
                    }

                    if (flag) {
                        //不管什么浏览器，一定是往上滚的
                        //往上滚   滑块往上跑   内容往下跑
                        //滑槽的高度 / 内容的高度 = 滑块滚动距离 / 内容的滚动距离 
                        var lastY = scrollIn.offsetTop - 10;
                        if (lastY < 0) {
                            lastY = 0;
                        }
                        scrollIn.style.top = lastY + 'px';
                        var contentDis = -scrollIn.offsetTop / scale;
                        content.style.top = contentDis + 'px';
                    } else {
                        //不管什么浏览器，一定是往下滚的
                        //往下滚   滑块往吓跑    内容往上跑
                        var lastY = scrollIn.offsetTop + 10;
                        if (lastY > document.documentElement.clientHeight scrollIn.offsetHeight) {
                            lastY = document.documentElement.clientHeight - scrollIn.offsetHeight
                        }
                        scrollIn.style.top = lastY + 'px';
                        var contentDis = -scrollIn.offsetTop / scale;
                        content.style.top = contentDis + 'px';
                    }

                }

            }
        </script>
    </body>
</html>
```

## 11. 轮播图逻辑点击按钮

原始页面：

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }
            ul,li{
                list-style: none;
            }

            img{
                display: block;
                /*vertical-align: middle;*/
            }

            a{
                text-decoration: none;
            }

            input{
                outline: none;
            }

            .clearFix:after{
                content: '';
                display: table;
                clear: both;
            }

            #box{
                position: relative;
                width: 600px;
                height: 300px;
                margin: 50px auto;
                overflow: hidden;
            }

            #box .list{
                width: 3000px;
                height: 300px;
            }

            #box .list li{
                float: left;
                width: 600px;
                height: 300px;
            }

            #box .list li img{
                width: 600px;
                height: 300px;
            }


            #box span{
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                width: 50px;
                height: 100px;
                background-color: rgba(200,200,200,.7);
                font-size: 50px;
                text-align: center;
                line-height: 100px;
                color: white;
                opacity: 0;
                transition: opacity 2s;
            }
            #box .left{
                left: 0;
            }
            #box .right{
                right: 0;
            }

            #box .iconList{
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                bottom: 10px;
                overflow: hidden;
            }

            #box .iconList li{
                float: left;
                width: 40px;
                height: 40px;
                margin-right: 10px;
                border-radius: 50%;
                background-color: gray;
            }

            #box .iconList li.current{
                background-color: red;
            }


        </style>
    </head>
    <body>
        <div id="box">

            <ul class="list">
                <li><img src="img/1.jpg"/></li>
                <li><img src="img/2.jpg"/></li>
                <li><img src="img/3.jpg"/></li>
                <li><img src="img/4.jpg"/></li>
                <li><img src="img/5.jpg"/></li>
            </ul>

            <span class="left">  <  </span>
            <span class="right">  >  </span>


            <ul class="iconList">
                <li class="current"></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </div>

        <script type="text/javascript">
            window.onload = function(){
                var box = document.getElementById('box');
                var spanNodes = document.querySelectorAll('#box span');

                //移入
                box.onmouseenter= function(){
                    spanNodes[0].style.opacity = 1;
                    spanNodes[1].style.opacity = 1;
                };
                //移出
                box.onmouseleave = function(){
                    spanNodes[0].style.opacity = 0;
                    spanNodes[1].style.opacity = 0;
                };
            }
        </script>
    </body>
</html>
```

+ 手动点击更换图片

```js
     //点击右侧按钮图片动起来
     spanNodes[1].onclick = function(){
             //可以求出目前ul所在的位置
             var startX = ulNode.offsetLeft;
             //也可以知道移动的距离差 -600
             var disX = -600;
             //我们就可以求出点击一次移动的最终位置
             var lastX = startX + disX;
             //把求出的最终位置设置给ul,这样点击就已经能轮播了，但是是瞬变轮播
             ulNode.style.left = lastX + 'px';
 }
```

+ 点击平滑切换

```js
                var ulNode = document.querySelector('#box .list');
                var timeAll = 600;//点击一次移动一张图片的距离所需要的总时间
                var stepTime = 20;//每都一步所需要的的时间
                var timer = null;
                //点击右侧按钮图片动起来
                spanNodes[1].onclick = function(){
                    //可以求出目前ul所在的位置
                    var startX = ulNode.offsetLeft;
                    //也可以知道移动的距离差 -600
                    var disX = -600;
                    //我们就可以求出点击一次移动的最终位置
                    var lastX = startX + disX;
                    //把求出的最终位置设置给ul,这样点击就已经能轮播了，但是是瞬变轮播
                    //如果要变成滑动就不能这样做，我们得让这个-600慢慢一步一步走；
//                    ulNode.style.left = lastX + 'px';
//                    用循环定时器模拟过度效果
                    //求出每一步走的距离
                    var stepDis = disX / (timeAll / stepTime);
                    timer = setInterval(function(){
                        var left = ulNode.offsetLeft + stepDis;
                        //当慢慢移动到最后和瞬间移动到最后距离一样的时候，我们就清除定时器
                        if(left === lastX){
                            clearInterval(timer);
                        }
                        ulNode.style.left = left + 'px';
                    },stepTime);

                }

                //点击左侧按钮
                spanNodes[0].onclick = function(){
                    //可以求出目前ul所在的位置
                    var startX = ulNode.offsetLeft;
                    //也可以知道移动的距离差 -600
                    var disX = 600;
                    //我们就可以求出点击一次移动的最终位置
                    var lastX = startX + disX;
                    //把求出的最终位置设置给ul,这样点击就已经能轮播了，但是是瞬变轮播
                    //如果要变成滑动就不能这样做，我们得让这个-600慢慢一步一步走；
//                    ulNode.style.left = lastX + 'px';
//                    用循环定时器模拟过度效果
                    //求出每一步走的距离
                    var stepDis = disX / (timeAll / stepTime);
                    timer = setInterval(function(){
                        var left = ulNode.offsetLeft + stepDis;
                        //当慢慢移动到最后和瞬间移动到最后距离一样的时候，我们就清除定时器
                        if(left === lastX){
                            clearInterval(timer);
                        }
                        ulNode.style.left = left + 'px';
                    },stepTime);

                }
```

+ 封装优化

```js
                var ulNode = document.querySelector('#box .list');
                var timeAll = 600;//点击一次移动一张图片的距离所需要的总时间
                var stepTime = 20;//每都一步所需要的的时间
                var timer = null;
                //点击右侧按钮图片动起来
                spanNodes[1].onclick = function(){
                    move(true);
                }
                //点击左侧按钮
                spanNodes[0].onclick = function(){
                    move(false);
                }

                function move(flag){
                    if(flag){
                        var disX = -600;
                    }else{
                        var disX = 600;
                    }
                    //可以求出目前ul所在的位置
                    var startX = ulNode.offsetLeft;
                    //我们就可以求出点击一次移动的最终位置
                    var lastX = startX + disX;
                    //把求出的最终位置设置给ul,这样点击就已经能轮播了，但是是瞬变轮播
                    //如果要变成滑动就不能这样做，我们得让这个-600慢慢一步一步走；
                    //ulNode.style.left = lastX + 'px';
                    //用循环定时器模拟过度效果
                    //求出每一步走的距离
                    var stepDis = disX / (timeAll / stepTime);
                    timer = setInterval(function(){
                        var left = ulNode.offsetLeft + stepDis;
                        //当慢慢移动到最后和瞬间移动到最后距离一样的时候，我们就清除定时器
                        if(left === lastX){
                            clearInterval(timer);
                        }
                        ulNode.style.left = left + 'px';
                    },stepTime);
                }
```

## 12. 无限循环点击轮播

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }
            ul,li{
                list-style: none;
            }

            img{
                display: block;
                /*vertical-align: middle;*/
            }

            a{
                text-decoration: none;
            }

            input{
                outline: none;
            }

            .clearFix:after{
                content: '';
                display: table;
                clear: both;
            }

            #box{
                position: relative;
                width: 600px;
                height: 300px;
                margin: 50px auto;
                overflow: hidden;
            }

            #box .list{
                position: absolute;
                left: -600px;
                top: 0;
                width: 4200px;
                height: 300px;
            }

            #box .list li{
                float: left;
                width: 600px;
                height: 300px;
            }

            #box .list li img{
                width: 600px;
                height: 300px;
            }


            #box span{
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                width: 50px;
                height: 100px;
                background-color: rgba(200,200,200,.7);
                font-size: 50px;
                text-align: center;
                line-height: 100px;
                color: white;
                opacity: 0;
                transition: opacity 2s;
            }
            #box .left{
                left: 0;
            }
            #box .right{
                right: 0;
            }

            #box .iconList{
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                bottom: 10px;
                overflow: hidden;
            }

            #box .iconList li{
                float: left;
                width: 40px;
                height: 40px;
                margin-right: 10px;
                border-radius: 50%;
                background-color: gray;
            }

            #box .iconList li.current{
                background-color: red;
            }


        </style>
    </head>
    <body>
        <div id="box">

            <ul class="list">
                <!--无缝效果需要改变结构  最前面加最后一个，最后面加最前面一个-->
                <li><img src="img/5.jpg"/></li>
                <li><img src="img/1.jpg"/></li>
                <li><img src="img/2.jpg"/></li>
                <li><img src="img/3.jpg"/></li>
                <li><img src="img/4.jpg"/></li>
                <li><img src="img/5.jpg"/></li>
                <li><img src="img/1.jpg"/></li>
            </ul>

            <span class="left">  <  </span>
            <span class="right">  >  </span>


            <ul class="iconList">
                <li class="current"></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </div>

        <script type="text/javascript">
            window.onload = function(){
                var box = document.getElementById('box');
                var spanNodes = document.querySelectorAll('#box span');
                var ulNode = document.querySelector('#box .list');


                var timeAll = 600;//点击一次移动一张图片的距离所需要的总时间
                var stepTime = 20;//每都一步所需要的的时间
                var timer = null;


                //移入
                box.onmouseenter= function(){
                    spanNodes[0].style.opacity = 1;
                    spanNodes[1].style.opacity = 1;
                };
                //移出
                box.onmouseleave = function(){
                    spanNodes[0].style.opacity = 0;
                    spanNodes[1].style.opacity = 0;
                };



                //点击右侧按钮图片动起来

                spanNodes[1].onclick = function(){
                    move(true);
                }

                //点击左侧按钮
                spanNodes[0].onclick = function(){
                    move(false);
                }


                function move(flag){
                    if(flag){
                        var disX = -600;
                    }else{
                        var disX = 600;
                    }
                    //可以求出目前ul所在的位置
                    var startX = ulNode.offsetLeft;
                    //我们就可以求出点击一次移动的最终位置
                    var lastX = startX + disX;
                    //把求出的最终位置设置给ul,这样点击就已经能轮播了，但是是瞬变轮播
                    //如果要变成滑动就不能这样做，我们得让这个-600慢慢一步一步走；
//                    ulNode.style.left = lastX + 'px';
//                    用循环定时器模拟过度效果
                    //求出每一步走的距离
                    var stepDis = disX / (timeAll / stepTime);
                    timer = setInterval(function(){
                        var left = ulNode.offsetLeft + stepDis;
                        //当慢慢移动到最后和瞬间移动到最后距离一样的时候，我们就清除定时器
                        if(left === lastX){
                            clearInterval(timer);
                            //无缝的逻辑
                            if(left === -3600){
                                left = -600;
                            }else if(left === 0){
                                left = -3000;
                            }
                        }
                        ulNode.style.left = left + 'px';
                    },stepTime);
                }

            }
        </script>
    </body>
</html>
```

## 13. 左右按钮联动小圆点变色

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }
            ul,li{
                list-style: none;
            }

            img{
                display: block;
                /*vertical-align: middle;*/
            }

            a{
                text-decoration: none;
            }

            input{
                outline: none;
            }

            .clearFix:after{
                content: '';
                display: table;
                clear: both;
            }

            #box{
                position: relative;
                width: 600px;
                height: 300px;
                margin: 50px auto;
                overflow: hidden;
            }

            #box .list{
                position: absolute;
                left: -600px;
                top: 0;
                width: 4200px;
                height: 300px;
            }

            #box .list li{
                float: left;
                width: 600px;
                height: 300px;
            }

            #box .list li img{
                width: 600px;
                height: 300px;
            }


            #box span{
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                width: 50px;
                height: 100px;
                background-color: rgba(200,200,200,.7);
                font-size: 50px;
                text-align: center;
                line-height: 100px;
                color: white;
                opacity: 0;
                transition: opacity 2s;
            }
            #box .left{
                left: 0;
            }
            #box .right{
                right: 0;
            }

            #box .iconList{
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                bottom: 10px;
                overflow: hidden;
            }

            #box .iconList li{
                float: left;
                width: 40px;
                height: 40px;
                margin-right: 10px;
                border-radius: 50%;
                background-color: gray;
            }

            #box .iconList li.current{
                background-color: red;
            }


        </style>
    </head>
    <body>
        <div id="box">

            <ul class="list">
                <!--无缝效果需要改变结构  最前面加最后一个，最后面加最前面一个-->
                <li><img src="img/9.jpg"/></li>
                <li><img src="img/17.jpg"/></li>
                <li><img src="img/2.jpg"/></li>
                <li><img src="img/3.jpg"/></li>
                <li><img src="img/7.jpg"/></li>
                <li><img src="img/9.jpg"/></li>
                <li><img src="img/17.jpg"/></li>
            </ul>

            <span class="left">  <  </span>
            <span class="right">  >  </span>


            <ul class="iconList">
                <li class="current"></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </div>

        <script type="text/javascript">
            window.onload = function(){
                var box = document.getElementById('box');
                var spanNodes = document.querySelectorAll('#box span');
                var ulNode = document.querySelector('#box .list');
                var iconItems = document.querySelectorAll('#box .iconList li');
                var timeAll = 600;//点击一次移动一张图片的距离所需要的总时间
                var stepTime = 20;//每都一步所需要的的时间
                var timer = null;


                //移入
                box.onmouseenter= function(){
                    spanNodes[0].style.opacity = 1;
                    spanNodes[1].style.opacity = 1;
                };
                //移出
                box.onmouseleave = function(){
                    spanNodes[0].style.opacity = 0;
                    spanNodes[1].style.opacity = 0;
                };



                //点击右侧按钮图片动起来

                spanNodes[1].onclick = function(){
                    move(true);
                }

                //点击左侧按钮
                spanNodes[0].onclick = function(){
                    move(false);
                }


                function move(flag){
                    if(flag){
                        var disX = -600;
                    }else{
                        var disX = 600;
                    }
                    //可以求出目前ul所在的位置
                    var startX = ulNode.offsetLeft;
                    //我们就可以求出点击一次移动的最终位置
                    var lastX = startX + disX;
                    //把求出的最终位置设置给ul,这样点击就已经能轮播了，但是是瞬变轮播
                    //如果要变成滑动就不能这样做，我们得让这个-600慢慢一步一步走；
//                    ulNode.style.left = lastX + 'px';
//                    用循环定时器模拟过度效果
                    //求出每一步走的距离
                    var stepDis = disX / (timeAll / stepTime);
                    timer = setInterval(function(){
                        var left = ulNode.offsetLeft + stepDis;
                        //当慢慢移动到最后和瞬间移动到最后距离一样的时候，我们就清除定时器
                        if(left === lastX){
                            clearInterval(timer);
                            //无缝的逻辑
                            if(left === -3600){
                                left = -600;
                            }else if(left === 0){
                                left = -3000;
                            }
                        }
                        ulNode.style.left = left + 'px';
                    },stepTime);

                    //小圆点变色
                    //排它
                    //先让所有的小圆点变灰
                    for(var i = 0; i < iconItems.length; i++){
                        iconItems[i].className = '';
                    }

                    //让对应的小圆点变红
                    //要求对应的小圆点，其实就是要求出对应的小圆点的下标
                    //想要求小圆点的下标，我们可以转而求要显示的图片的下标，
                    //图片下标 - 1就是我们要的小圆点下标
                    var index = lastX / -600 - 1;
                    if(index > 4){
                        index = 0;
                    }else if(index < 0){
                        index = 4;
                    }

                    iconItems[index].className = 'current';            
                }    
            }
        </script>
    </body>
</html>
```

## 14. 点击小圆点切换变色

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }
            ul,li{
                list-style: none;
            }

            img{
                display: block;
                /*vertical-align: middle;*/
            }

            a{
                text-decoration: none;
            }

            input{
                outline: none;
            }

            .clearFix:after{
                content: '';
                display: table;
                clear: both;
            }

            #box{
                position: relative;
                width: 600px;
                height: 300px;
                margin: 50px auto;
                overflow: hidden;
            }

            #box .list{
                position: absolute;
                left: -600px;
                top: 0;
                width: 4200px;
                height: 300px;
            }

            #box .list li{
                float: left;
                width: 600px;
                height: 300px;
            }

            #box .list li img{
                width: 600px;
                height: 300px;
            }


            #box span{
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                width: 50px;
                height: 100px;
                background-color: rgba(200,200,200,.7);
                font-size: 50px;
                text-align: center;
                line-height: 100px;
                color: white;
                opacity: 0;
                transition: opacity 2s;
            }
            #box .left{
                left: 0;
            }
            #box .right{
                right: 0;
            }

            #box .iconList{
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                bottom: 10px;
                overflow: hidden;
            }

            #box .iconList li{
                float: left;
                width: 40px;
                height: 40px;
                margin-right: 10px;
                border-radius: 50%;
                background-color: gray;
            }

            #box .iconList li.current{
                background-color: red;
            }


        </style>
    </head>
    <body>
        <div id="box">

            <ul class="list">
                <!--无缝效果需要改变结构  最前面加最后一个，最后面加最前面一个-->
                <li><img src="img/9.jpg"/></li>
                <li><img src="img/17.jpg"/></li>
                <li><img src="img/2.jpg"/></li>
                <li><img src="img/3.jpg"/></li>
                <li><img src="img/7.jpg"/></li>
                <li><img src="img/9.jpg"/></li>
                <li><img src="img/17.jpg"/></li>
            </ul>

            <span class="left">  <  </span>
            <span class="right">  >  </span>


            <ul class="iconList">
                <li class="current"></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </div>

        <script type="text/javascript">
            window.onload = function(){
                var box = document.getElementById('box');
                var spanNodes = document.querySelectorAll('#box span');
                var ulNode = document.querySelector('#box .list');
                var iconItems = document.querySelectorAll('#box .iconList li');
                var timeAll = 600;//点击一次移动一张图片的距离所需要的总时间
                var stepTime = 20;//每都一步所需要的的时间
                var timer = null;


                //移入
                box.onmouseenter= function(){
                    spanNodes[0].style.opacity = 1;
                    spanNodes[1].style.opacity = 1;
                };
                //移出
                box.onmouseleave = function(){
                    spanNodes[0].style.opacity = 0;
                    spanNodes[1].style.opacity = 0;
                };



                //点击右侧按钮图片动起来

                spanNodes[1].onclick = function(){
                    move(true);
                }

                //点击左侧按钮
                spanNodes[0].onclick = function(){
                    move(false);
                }

                //点击小圆点移动
                for(var i = 0; i < iconItems.length; i++){
                    iconItems[i].index = i;
                    iconItems[i].onclick = function(){
                        //点击小圆点后的逻辑
                        //和小圆点变色求小圆点的下标  刚好相反
                        //点击哪个小圆点，可以获取到点击的这个小圆点的下标
                        //根据小圆点的下标可以求出要显示的图片的下标
                        //就可以求出要显示的图片对应的最终位置
                        //把最终位置传到move可以求出点击小圆点后的距离差
                        //点击按钮和点击小圆点逻辑是一样的，只是距离差不同
                        move((this.index + 1)* -600);
                    }
                }

                function move(flag){
                    if(typeof flag === "boolean"){
                        //证明点击的是按钮
                        if(flag){
                            var disX = -600;
                        }else{
                            var disX = 600;
                        }
                    }else{
                        //证明点击的是小圆点进来的flag不是布尔值
                        var disX = flag - ulNode.offsetLeft;
                    }

                    //可以求出目前ul所在的位置
                    var startX = ulNode.offsetLeft;
                    //我们就可以求出点击一次移动的最终位置
                    var lastX = startX + disX;
                    //把求出的最终位置设置给ul,这样点击就已经能轮播了，但是是瞬变轮播
                    //如果要变成滑动就不能这样做，我们得让这个-600慢慢一步一步走；
//                    ulNode.style.left = lastX + 'px';
//                    用循环定时器模拟过度效果
                    //求出每一步走的距离
                    var stepDis = disX / (timeAll / stepTime);
                    timer = setInterval(function(){
                        var left = ulNode.offsetLeft + stepDis;
                        //当慢慢移动到最后和瞬间移动到最后距离一样的时候，我们就清除定时器
                        if(left === lastX){
                            clearInterval(timer);
                            //无缝的逻辑
                            if(left === -3600){
                                left = -600;
                            }else if(left === 0){
                                left = -3000;
                            }
                        }
                        ulNode.style.left = left + 'px';
                    },stepTime);

                    //小圆点变色
                    //排它
                    //先让所有的小圆点变灰
                    for(var i = 0; i < iconItems.length; i++){
                        iconItems[i].className = '';
                    }

                    //让对应的小圆点变红
                    //要求对应的小圆点，其实就是要求出对应的小圆点的下标
                    //想要求小圆点的下标，我们可以转而求要显示的图片的下标，
                    //图片下标 - 1就是我们要的小圆点下标
                    var index = lastX / -600 - 1;
                    if(index > 4){
                        index = 0;
                    }else if(index < 0){
                        index = 4;
                    }

                    iconItems[index].className = 'current';
                }
            }
        </script>
    </body>
</html>
```

## 15. 定时器叠加问题

发生情况：连续点击  定时器执行的时间的间隔很短

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }
            ul,li{
                list-style: none;
            }

            img{
                display: block;
                /*vertical-align: middle;*/
            }

            a{
                text-decoration: none;
            }

            input{
                outline: none;
            }

            .clearFix:after{
                content: '';
                display: table;
                clear: both;
            }

            #box{
                position: relative;
                width: 600px;
                height: 300px;
                margin: 50px auto;
                overflow: hidden;
            }

            #box .list{
                position: absolute;
                left: -600px;
                top: 0;
                width: 4200px;
                height: 300px;
            }

            #box .list li{
                float: left;
                width: 600px;
                height: 300px;
            }

            #box .list li img{
                width: 600px;
                height: 300px;
            }


            #box span{
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                width: 50px;
                height: 100px;
                background-color: rgba(200,200,200,.7);
                font-size: 50px;
                text-align: center;
                line-height: 100px;
                color: white;
                opacity: 0;
                transition: opacity 2s;
            }
            #box .left{
                left: 0;
            }
            #box .right{
                right: 0;
            }

            #box .iconList{
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                bottom: 10px;
                overflow: hidden;
            }

            #box .iconList li{
                float: left;
                width: 40px;
                height: 40px;
                margin-right: 10px;
                border-radius: 50%;
                background-color: gray;
            }

            #box .iconList li.current{
                background-color: red;
            }


        </style>
    </head>
    <body>
        <div id="box">

            <ul class="list">
                <!--无缝效果需要改变结构  最前面加最后一个，最后面加最前面一个-->
                <li><img src="img/9.jpg"/></li>
                <li><img src="img/17.jpg"/></li>
                <li><img src="img/2.jpg"/></li>
                <li><img src="img/3.jpg"/></li>
                <li><img src="img/7.jpg"/></li>
                <li><img src="img/9.jpg"/></li>
                <li><img src="img/17.jpg"/></li>
            </ul>

            <span class="left">  <  </span>
            <span class="right">  >  </span>


            <ul class="iconList">
                <li class="current"></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </div>

        <script type="text/javascript">
            window.onload = function(){
                var box = document.getElementById('box');
                var spanNodes = document.querySelectorAll('#box span');
                var ulNode = document.querySelector('#box .list');
                var iconItems = document.querySelectorAll('#box .iconList li');
                var timeAll = 600;//点击一次移动一张图片的距离所需要的总时间
                var stepTime = 20;//每都一步所需要的的时间
                var timer = null;
                var isMove = false;

                //移入
                box.onmouseenter= function(){
                    spanNodes[0].style.opacity = 1;
                    spanNodes[1].style.opacity = 1;
                };
                //移出
                box.onmouseleave = function(){
                    spanNodes[0].style.opacity = 0;
                    spanNodes[1].style.opacity = 0;
                };
                //点击右侧按钮图片动起来

                spanNodes[1].onclick = function(){
                    move(true);
                }
                //点击左侧按钮
                spanNodes[0].onclick = function(){
                    move(false);
                }

                //点击小圆点移动
                for(var i = 0; i < iconItems.length; i++){
                    iconItems[i].index = i;
                    iconItems[i].onclick = function(){
                        move((this.index + 1)* -600);
                    }
                }

                function move(flag){
                    //第二次开始的时候去判断开关状态；
                    if(isMove){
                        return;
                    }
                    //第一次点击的时候
                    isMove = true;

                    if(typeof flag === "boolean"){
                        //证明点击的是按钮
                        if(flag){
                            var disX = -600;
                        }else{
                            var disX = 600;
                        }
                    }else{
                        //证明点击的是小圆点进来的flag不是布尔值
                        var disX = flag - ulNode.offsetLeft;
                    }

                    //可以求出目前ul所在的位置
                    var startX = ulNode.offsetLeft;
                    //我们就可以求出点击一次移动的最终位置
                    var lastX = startX + disX;
                    var stepDis = disX / (timeAll / stepTime);
                    timer = setInterval(function(){
                        var left = ulNode.offsetLeft + stepDis;
                        //当慢慢移动到最后和瞬间移动到最后距离一样的时候，我们就清除定时器
                        if(left === lastX){
                            clearInterval(timer);
                            //无缝的逻辑
                            if(left === -3600){
                                left = -600;
                            }else if(left === 0){
                                left = -3000;
                            }
                            //在特定的条件下，让isMove再次变为false,为了后期也能动，否则后期点击就不动了
                            isMove = false;

                        }
                        ulNode.style.left = left + 'px';
                    },stepTime);

                    //小圆点变色
                    //排它
                    //先让所有的小圆点变灰
                    for(var i = 0; i < iconItems.length; i++){
                        iconItems[i].className = '';
                    }

                    var index = lastX / -600 - 1;
                    if(index > 4){
                        index = 0;
                    }else if(index < 0){
                        index = 4;
                    }

                    iconItems[index].className = 'current';
                }
            }
        </script>
    </body>
</html>
```

## 16. 自动轮播

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            *{
                margin: 0;
                padding: 0;
            }
            ul,li{
                list-style: none;
            }

            img{
                display: block;
                /*vertical-align: middle;*/
            }

            a{
                text-decoration: none;
            }

            input{
                outline: none;
            }

            .clearFix:after{
                content: '';
                display: table;
                clear: both;
            }

            #box{
                position: relative;
                width: 600px;
                height: 300px;
                margin: 50px auto;
                overflow: hidden;
            }

            #box .list{
                position: absolute;
                left: -600px;
                top: 0;
                width: 4200px;
                height: 300px;
            }

            #box .list li{
                float: left;
                width: 600px;
                height: 300px;
            }

            #box .list li img{
                width: 600px;
                height: 300px;
            }


            #box span{
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                width: 50px;
                height: 100px;
                background-color: rgba(200,200,200,.7);
                font-size: 50px;
                text-align: center;
                line-height: 100px;
                color: white;
                opacity: 0;
                transition: opacity 2s;
            }
            #box .left{
                left: 0;
            }
            #box .right{
                right: 0;
            }

            #box .iconList{
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                bottom: 10px;
                overflow: hidden;
            }

            #box .iconList li{
                float: left;
                width: 40px;
                height: 40px;
                margin-right: 10px;
                border-radius: 50%;
                background-color: gray;
            }

            #box .iconList li.current{
                background-color: red;
            }


        </style>
    </head>
    <body>
        <div id="box">

            <ul class="list">
                <!--无缝效果需要改变结构  最前面加最后一个，最后面加最前面一个-->
                <li><img src="img/9.jpg"/></li>
                <li><img src="img/17.jpg"/></li>
                <li><img src="img/2.jpg"/></li>
                <li><img src="img/3.jpg"/></li>
                <li><img src="img/7.jpg"/></li>
                <li><img src="img/9.jpg"/></li>
                <li><img src="img/17.jpg"/></li>
            </ul>

            <span class="left">  <  </span>
            <span class="right">  >  </span>


            <ul class="iconList">
                <li class="current"></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </div>

        <script type="text/javascript">
            window.onload = function(){
                var box = document.getElementById('box');
                var spanNodes = document.querySelectorAll('#box span');
                var ulNode = document.querySelector('#box .list');
                var iconItems = document.querySelectorAll('#box .iconList li');
                var timeAll = 600;//点击一次移动一张图片的距离所需要的总时间
                var stepTime = 20;//每都一步所需要的的时间
                var timer = null;
                var isMove = false;
                var autoTimer = null;

                //移入
                box.onmouseenter= function(){
                    spanNodes[0].style.opacity = 1;
                    spanNodes[1].style.opacity = 1;
                    clearInterval(autoTimer);
                };
                //移出
                box.onmouseleave = function(){
                    spanNodes[0].style.opacity = 0;
                    spanNodes[1].style.opacity = 0;
                    autoRun();
                };



                //点击右侧按钮图片动起来

                spanNodes[1].onclick = function(){
                    move(true);
                }

                //点击左侧按钮
                spanNodes[0].onclick = function(){
                    move(false);
                }

                //点击小圆点移动
                for(var i = 0; i < iconItems.length; i++){
                    iconItems[i].index = i;
                    iconItems[i].onclick = function(){
                        //点击小圆点后的逻辑
                        //和小圆点变色求小圆点的下标  刚好相反
                        //点击哪个小圆点，可以获取到点击的这个小圆点的下标
                        //根据小圆点的下标可以求出要显示的图片的下标
                        //就可以求出要显示的图片对应的最终位置
                        //把最终位置传到move可以求出点击小圆点后的距离差
                        //点击按钮和点击小圆点逻辑是一样的，只是距离差不同
                        move((this.index + 1)* -600);
                    }
                }

                //自动轮播
                autoRun();
                function autoRun(){
                    autoTimer = setInterval(function(){
                        move(true);
                    },2000);
                }
                function move(flag){

                    //第二次开始的时候去判断开关状态；
                    if(isMove){
                        return;
                    }

                    //第一次点击的时候
                    isMove = true;

                    if(typeof flag === "boolean"){
                        //证明点击的是按钮
                        if(flag){
                            var disX = -600;
                        }else{
                            var disX = 600;
                        }
                    }else{
                        //证明点击的是小圆点进来的flag不是布尔值
                        var disX = flag - ulNode.offsetLeft;
                    }

                    //可以求出目前ul所在的位置
                    var startX = ulNode.offsetLeft;
                    //我们就可以求出点击一次移动的最终位置
                    var lastX = startX + disX;
                    //把求出的最终位置设置给ul,这样点击就已经能轮播了，但是是瞬变轮播
                    //如果要变成滑动就不能这样做，我们得让这个-600慢慢一步一步走；
//                    ulNode.style.left = lastX + 'px';
//                    用循环定时器模拟过度效果
                    //求出每一步走的距离
                    var stepDis = disX / (timeAll / stepTime);
                    timer = setInterval(function(){
                        var left = ulNode.offsetLeft + stepDis;
                        //当慢慢移动到最后和瞬间移动到最后距离一样的时候，我们就清除定时器
                        if(left === lastX){
                            clearInterval(timer);
                            //无缝的逻辑
                            if(left === -3600){
                                left = -600;
                            }else if(left === 0){
                                left = -3000;
                            }
                            isMove = false;

                        }
                        ulNode.style.left = left + 'px';
                    },stepTime);

                    //小圆点变色
                    //排它
                    //先让所有的小圆点变灰
                    for(var i = 0; i < iconItems.length; i++){
                        iconItems[i].className = '';
                    }
                    var index = lastX / -600 - 1;
                    if(index > 4){
                        index = 0;
                    }else if(index < 0){
                        index = 4;
                    }

                    iconItems[index].className = 'current';
                }

            }
        </script>
    </body>
</html>
```

##### 补充：数组的includes方法和字符串的includes方法的区别

- 数组的includes方法必须满足全等===的条件才返回true，

- 字符串的includes方法只要包含满足条件就返回true，不需要满足全等条件
  
  注意字符串会区分大小写的不同

```js
   const pets = ['cat', 'dog', 'bat'];
   console.log(pets.includes('ca')); // false，必须全等，数组pets里没有ca这个元素
   console.log(pets.includes('cat')); // true, 数组pets里有cat这个元素

   var str = 'cat dog bat'
   console.log(str.includes('d')) // true,字符串无需满足全等条件，只要包含参数d就返回true，字符串里有d这个字母
   console.log(str.includes('D')) // false，字符串区分大小写
```
