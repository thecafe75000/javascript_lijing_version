> **部门：尚硅谷大前端教学部**
> 
> **作者：李晶**

## 一、JavaScript概要

### 1. 为什么要学习JavaScript？

![01](.\img\01.png)

- **HTML**是一种标记语言，用来结构化我们的网页内容并赋予内容含义，例如定义段落、标题，或在页面中嵌入图片和视频。

- **CSS**是一种样式规则语言，可将样式应用于 HTML 内容， 例如设置背景颜色和字体，在多个列中布局内容。

- **JavaScript**是一种脚本语言，可以用来创建动态更新的内容，控制多媒体，制作图像动画，还有很多。
  
  这三层依次建立，秩序井然。

案例：

​            珍爱网----表单数据验证

​            淘宝动态数据渲染

### 2.  JavaScript<font color='red'>应用场景</font>

1. 表单验证
2. 网页动态效果（轮播，漂浮的广告）
3. 记住用户名字和密码
4. 游戏开发-经典案例俄罗斯方块
5. 页面中所有的能动的效果都是js来实现的
6. 页面中所有数据的渲染
7. nodejs react vue  小程序底层

### 3. 什么是JavaScript

![02](.\img\02.png)

官方解释：JavaScript 是一种**跨平台**的**脚本**语言。

> 平台：一般指的是运行环境，这里指的是操作系统
> 
> 跨平台：就是在很多种操作系统中都可以运行

![18](.\img\18.png)

> <font color='blue'>**脚本语言：特点是不能独立运行，需要依赖于网页**。</font>

ps：JavaScript程序的运行离不开HTML，HTML的运行离不开浏览器。

![19](.\img\19.png)

​    JavaScript是一种属于网络的脚本语言，已经被广泛用于Web应用开发，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的浏览效果。

作为一个Web开发师，如果你想提供漂亮的网页、令用户满意的上网体验，JavaScript是必不可少的工具。

### 4. JavaScript历史

1. 1995 年 2 月，Netscape 公司发布 Netscape Navigator 2 浏览器，并在这个浏览器中免费提供了一个开发工具——LiveScript。由于当时 Java 比较流行，Netscape 便把 LiveScript 改名为 JavaScript，这也是最初的 JavaScript 1.0 版本。
2. 由于 JavaScript 1.0 很受欢迎，Netscape 在 Netscape Navigator 3 中又发布了 JavaScript 1.1 版本。不久，微软在 Internet Explorer 3 中也加入了脚本编程功能。为了避免与 Netscape 的 JavaScript 产生纠纷，微软特意将其命名为 JScript。
3. 1997 年，欧洲计算机制造商协会（ECMA）以 JavaScript 1.1 为基础制订了脚本语言标准——ECMA-262，并命名为 ECMAScript。
4. 1998 年，国际标准化组织和国际电工委员会（ISO/IEC）采用了 ECMAScript 标准（即 ISO/IEC-16262）。自此，浏览器厂商就以 ECMAScript 作为各自 JavaScript 实现的规范标准。JavaScript 正式从各自为政走向了规范统一。

### 5. ECMAScript 起源

1997 年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了脚本语言的实现标准，并将这种语言命名为 ECMAScript。这个版本就是 ECMAScript 1.0 版。

之所以不叫 JavaScript，主要有以下两个原因：

- 商标限制。Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法使用 JavaScript 这个名字，而且 JavaScript 己经被 Netscape 公司注册为商标。
- 体现公益性。该标准的制订者是 ECMA 组织，而不是 Netscape 公司，这样有利于确保规范的开放性和中立性。

简单概括，ECMAScript 是 JavaScript 语言的规范标准，JavaScript 是 ECMAScript 的一种实现。注意，这两个词在一般语境中是可以互换的。

### 6. ECMAScript 版本

1. 1998 年 6 月，ECMAScript 2.0 版发布。
2. 1999 年 12 月，ECMAScript 3.0 版发布，并成为 JavaScript 的通用标准，获得广泛支持。
3. 2007 年 10 月，ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级。由于 4.0 版的目标过于激进，各方对于是否通过这个标准产生了严重分歧。
4. 2008 年 7月，ECMA 中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分发布为 ECMAScript 3.1。不久，ECMAScript 3.1 改名为 ECMAScript 5。
5. 2009 年 12 月，ECMAScript 5.0 版正式发布。
6. 2011 年 6 月，ECMAScript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。
7. 2013 年 12 月，ECMAScript 6 版草案发布。
8. 2015 年 6 月，ECMAScript 6 发布正式版本，并更名为 ECMAScript 2015 。Mozilla 在这个标准的基础上推出了 JavaScript 2.0。
9. 从此以后，JavaScript 开始以年份命名，新版本将按照 “ECMAScript+年份” 的形式发布。目前最新 版本为 ECMAScript 2018，于 2018 年 7 月正式发布。

![19](.\img\111.jpg)

### 7. 浏览器支持

目前 5 大主流浏览器都支持 ECMAScript 5，具体说明如下：

- IE 9+
- Chrome 13+
- Firefox 4+
- Safari 5.1+
- Opera 11.60+

![20](.\img\20.png)

### 8. JavaScript 构成

+ javscript
  + 浏览器环境的javascript, 包含以下3个部分：
    + ecmascript   基础语法  书写规范。很基本的东西    语法标准。
    + dom
    + bom
  + nodejs环境中的javascript
    + ecmascript
    + promise
    + axios
    + 。。。

![14](.\img\14.png)

ECMAScript 是 JavaScript 的标准，但它并不等同于 JavaScript，也不是唯一被标准化的规范。

<font color='red'>实际上，一个完整的 JavaScript 实现由以下 3 个不同部分组成：</font>

- 核心（ECMAScript）：语言核心部分。
- 文档对象模型（Document Object Model，DOM）：网页文档操作标准。
- 浏览器对象模型（BOM）：客户端和浏览器窗口操作基础。

## 二、JavaScript基本使用

### 1. JavaScript初体验

1. 在 HTML 中，JavaScript 代码必须位于` <script> `与 `</script>` 标签之间。
   
   ```html
   <script>
       alert('这是我们的第一个js代码')；
   </script>
   ```
   
   注释：旧的 JavaScript 例子也许会使用 type 属性：`<script type="text/javascript">`。
   
   注释：type 属性不是必需的。JavaScript 是 HTML 中的默认脚本语言。

### 2. JavaScript书写位置

#### 2.1 内联JavaScript

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>内联JavaScript</title>
    </head>
    <body>
        <button onclick="alert(207204858);">内联JavaScript</button>
    </body>
</html>
```

> 注意：请不要这样做，HTML代码被JavaScript代码污染了，结构和动作没有分离，但是在react和vue阶段使用的很多.

#### 2.2 内部JavaScript

+ `内部JavaScript`基本使用
  
  > 在 HTML 中，JavaScript 代码必须位于` <script> `与 `</script>` 标签之间。
  
  ```html
  <script>
      alert("欢迎光临红浪漫");
  </script>
  ```
  
  注意：旧的 JavaScript 例子也许会使用 type 属性：`<script type="text/javascript">`。
  
  ​            type 属性不是必需的。JavaScript 是 HTML 中的默认脚本语言。

+ `<head>`中的JavaScript
  
  ```html
  <!DOCTYPE html>
  <html>
      <head>
          <meta charset="UTF-8" />
          <title>head中的JavaScript</title>
          <script>
              alert("那一年我双手插兜，不知道什么叫做对手");
          </script>
      </head>
      <body> 
      </body>
  </html>
  ```

+ `<body>`中的JavaScript
  
  ```html
  <!DOCTYPE html>
  <html>
      <head>
          <meta charset="UTF-8" />
          <title>body中的JavaScript</title>
      </head>
      <body>
          <script>
              alert("故事里的小黄花，从出生那年就飘着");
          </script>
      </body>
  </html>
  ```

+ `<head>`和`<body>`中的JavaScript执行顺序
  
  ```html
  <!DOCTYPE html>
  <html>
      <head>
          <meta charset="UTF-8" />
          <title>head和body中的JavaScript的执行顺序</title>
          <script>
              alert("那一年我双手插兜，不知道什么事对手");
          </script>
      </head>
      <body>
          <script>
              alert("故事里的小黄花，从出生那年就飘着");
          </script>
      </body>
  </html>
  ```

+ `内部JavaScript`的书写位置
  
  > 浏览器对html页面内容的加载是顺序加载，也就是在html页面中前面先加载。当浏览器加载html文件并解析到`<head>`时,`<body>`并没有被解析,所以在使用box的时候,并没有box,所以颜色不会变化,但是当放在body的最后,那么就可以获取到box了.
  
  ```html
  <!DOCTYPE html>
  <html>
      <head>
          <meta charset="UTF-8" />
          <title>内部JavaScript的书写位置</title>
          <script>
              var box = document.getElementById("box");
              box.style.color = "green";
          </script>
      </head>
      <body>
          <div id="box">童年的荡秋千，随记忆一直晃到现在</div>
      </body>
  </html>
  ```
  
  总结：
  
  + 代码层面：如果把`JavaScript`放在`head`里的话，则先被解析,但这时候`body`还没有解析（常规html结构都是head在前，body在后）。如果head里面的`JavaScript`代码需要使用到`body`中代码，那么这个时候就会不好使，因为还没有执行到body里面的代码。
  + 性能方面：由于脚本会阻塞其他资源的下载（如图片等）和页面渲染，直到脚本全部下载并执行完成后，页面的渲染才会继续，<font color='blue'>因此推荐将所有的 <script> 标签尽可能放到 <body> 标签的底部，以尽量减少对整个页面下载的影响。</font>

#### 2.3 外部JavaScript

+ `外部JavaScript`基本使用
  
  > + JavaScript代码不仅可以直接写在HTML文档中，也可以放在JavaScript文件中，后缀名是.js。
  > 
  > + JS文件不能够单独运行，需要使用 `<script>`标签的`src`属性导入到网页中。
  > 
  > + 定义src属性的`<script>`标签不应该再含有JavaScript代码，否则只会下载并执行外部JavaScript文件，嵌入代码被忽略。
  
  ```html
  1）创建一个js文件，名称为first.js
  2) 引入js文件
      <html>
          <head>
              <title></title>
          </head>
          <body>
            <script src='first.js'></script>
          </body>
      </html>
  ```
  
  总结：`外部JavaScript`分离了 HTML代码 和JavaScript代码

+ `内联JavaScript`，`内部JavaScript`和`外部JavaScript`的执行顺序
  
  ```html
  <!DOCTYPE html>
  <html>
      <head>
          <meta charset="UTF-8" />
          <title>内联JavaScript，内部JavaScript和外部JavaScript的执行顺序</title>
      </head>
      <body>
          <script src="first.js"></script>
          <script>
              alert("男宾2位");
          </script>
          <button onclick="alert(857);">内联JavaScript</button> 
      </body>
  </html>
  ```
  
  总结：JavaScript的执行顺序只和书写顺序有关系。

#### 2.4  延迟执行JS-defer

- `<script>`标签有一个布尔型属性defer，这个属性的用途是表明脚本在执行时不会影响页面的构造，也就是说，脚本会被延迟到整个页面都解析完成后再运行。
- 因此在script元素中设置defer属性，相当于告诉浏览器立即下载，但是延迟执行
- 如果页面中有多个延迟脚本，那么第一个延迟脚本会先于第二个延迟脚本执行
- 适用于外部JS文件，不适用于script标签包含的脚本

```html
1）创建一个js文件，名称为first.js
2) 引入js延迟文件
  <!DOCTYPE html>
  <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Document</title>
            <script src="./first.js" defer></script>
            <script>
                alert("head引入js")
            </script>
        </head>
        <body>
            <script>
                alert("body末尾引入js")
            </script>
        </body>
  </html>
```

#### 2.5  异步加载JS文件-async

- 在默认情况下，网页都是同步加载外部 JavaScript文件的，在引入外部js文件时会阻塞代码的执行，为此在html4.01为script标签引入了async属性

- 现在可以为`<script>`标签设置 async属性，让浏览器异步加载 Javascript文件，即表示应该立即下载脚本，但不应妨碍页面汇总的其它操作。只对外部脚本文件有效。

- 因为是下载完立即执行，不能保证多个加载时的先后顺序，因此确保异步脚本之间互不依赖
  
  ```html
  1）创建一个js文件，名称为first.js
  2）引入js文件
      <!DOCTYPE html>
      <html lang="en">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Document</title>
              <script src="a.js" async></script>
          </head>
          <body>
             这是测试async的小案例，一jiao wulijiaojiao
          </body>
      </html>
  ```

### 3. JavaScript 输出

JavaScript 能够以不同方式“显示”数据, 有4种输出方式：

- 使用 window.alert() 写入警告框

- 使用 document.write() 写入 HTML 输出

- 使用 innerHTML 写入 HTML 元素

- 使用 console.log() 写入浏览器控制台
1. alert
   
   您能够使用警告框来显示数据：
   
   ```html
   <!DOCTYPE html>
   <html>
     <body>
         <script>
               //和alert是一样的，后续window对象时候讲解
                 window.alert('故事里的小黄花');
         </script>
     </body>
   </html> 
   ```

2. document.write
   
   1) 可以向HTML输出流中插入你传入的内容，浏览器会按着HTML元素依次顺序依次解析它们，并显示出来。
   
   ```html
   <!DOCTYPE html>
   <html>
     <body>
         <script>
                 document.write('从出生那年就飘着');
         </script>
     </body>
   </html> 
   ```
   
   2) 需要注意的是，如果在文档加载完成后（即HTML输出已完成），再使用document.write()方法来要求浏览器来解析你的内容，则浏览器就会重写整个document，导致最后的这个document.write()方法输出的内容会覆盖之前所有的内容
   
   ```html
   <!DOCTYPE html>
   <html>
       <body>
           <h6>淡黄的长裙</h6>
           <h6>蓬松的头发</h6>
           <button onclick="document.write('<h1>什么玩意儿</h1>')">试一试</button>
       </body>
   </html>
   ```

3. innerHTML
   
   id 属性定义 HTML 元素。innerHTML 属性定义 HTML 内容：
   
   ```html
   <!DOCTYPE html>
   <html>
      <body>
          <p id="demo"></p>
          <script>
              document.getElementById("demo").innerHTML = '我们的开始，是漫长的电影';
          </script>
      </body>
   </html> 
   ```

4. console.log
   
   在浏览器中，您可使用 console.log() 方法来显示数据。
   
   请通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”。
   
   ```html
   <!DOCTYPE html>
   <html>
      <body>
          <p id="demo"></p>
          <script>
              console.log('苍茫的天涯是的爱');
          </script>
      </body>
   </html> 
   ```

### 4. JavaScript语句

1. 分号;

```js
var a = 1;
var b = 2;
var c = a + b;
```

如果有分号分隔，允许在同一行写多条语句：

```js
var a = 1; var b = 2; var c = a + b;
```

2. js的代码的行长度和折行

为了达到最佳的可读性，程序员们常常喜欢把代码行控制在 80 个字符以内。

可以在文本字符串中使用反斜杠对代码行进行换行

```html
<!DOCTYPE html>
<html>
    <body>
        <script>
            document.write('我一路向北 \
            离开有你的季节');
        </script>
    </body>
</html> 
```

不能像这样折行

```html
<!DOCTYPE html>
<html>
    <body>
        <script>
            document.write \ 
            ("你好世界!");
        </script>
    </body>
</html> 
```

3. js空白字符

js会忽略多个空格。您可以向脚本添加空格，以增强可读性

这两行是相等的：

```js
var name = "emo";
var name="emo"; 
```

在运算符旁边（ = + - * / ）添加空格是个好习惯：

```js
var x = y + z;
```

### 5. JavaScript注释

+ 单行注释
  
  单行注释以 // 开头。
  
  任何位于 // 与行末之间的文本都会被 JavaScript 忽略（不会执行）。
  
  ```html
  <!DOCTYPE html>
  <html>
      <body>
          <script>
              // 我是一个注释
              document.write("乘着风游荡在蓝天边");
          </script>
      </body>
  </html> 
  ```

+ 多行注释
  
  多行注释以 /* 开始，以 */ 结尾。
  
  ```html
  <!DOCTYPE html>
  <html>
      <head>
          <meta charset='utf-8'>
      </head>
      <body>
          <script>
              /* 
              祭司神殿征战弓箭是谁的从前，
              喜欢在人潮中你只属於我的那画面，
              经过苏美女神身边，我以女神之名许愿，
              思念像底格里斯河般的漫延，当古文明只剩下难解的语言，
              传说就成了永垂不朽的诗篇
              */
              document.write("乘着风游荡在蓝天边");
          </script>
      </body>
  </html> 
  ```

+ 在行末使用注释
  
  ```html
  <!DOCTYPE html>
  <html>
      <head>
          <meta charset='utf-8'>
      </head>
      <body>
          <script>
              document.write("乘着风游荡在蓝天边"); //繁华如三千东流水，我只取一瓢爱了解
          </script>
      </body>
  </html> 
  ```

### 6. JavaScript变量

#### 6.1 为什么学习变量

思考：下列代码有什么问题？

```html
<script>
        console.log(1234567890);
        console.log(1234567890);
        console.log(1234567890);
        console.log(1234567890);
        console.log(1234567890);
        console.log(1234567890);
        console.log(1234567890);
</script>
```

> 1.同一个值多次使用，重复性太高
> 
> 2.同一个值多次使用，修改显得很繁琐

#### 6.2 变量的定义

**定义**：值可以被修改的量叫做变量

**格式**：定义一个变量：`var x = 1;`

+ x 叫做变量名
+ 1 叫做字面量/值

**说明**：

- 变量相当于容器，值相当于容器内装的东西，而变量名就是容器上贴着的标签，通过标签可以找到变量。

#### 6.3 变量定义的详解

##### 6.3.1 声明

> 概念：公开表态或说明

`var age;`

##### 6.3.2 初始化

> 概念：在计算机编程领域中指为`数据对象`或`变量`赋`初值`的做法

`age = 18;`

##### 6.3.3 特殊情况说明

案例1：在一个 var 语句中，可以声明一个或多个变量，也可以为变量赋值，未赋值的变量初始化为 undefined（未定义）值。当声明多个变量时，应使用逗号运算符分隔。 

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset='utf-8'>
    </head>
    <body>
        <script>
            var a;  //声明一个变量
            var a,b,c;  //声明多个变量
            var a,b = 1;//会将1赋值给最后一个变量
            var b = 1; //声明并赋值（常用）
        </script>
    </body>
</html> 
```

案例2：在 js中，可以重复声明同一个变量同时也可以反复初始化变量的值。但是没有用，只有最后的值有效.

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset='utf-8'>
    </head>
    <body>
        <script>
            var a = 1;
            var a = 2;
            var a = 3;
            console.log(a); // 3
        </script>
    </body>
</html> 
```

> 友情提示：
> 
> ​      在**非严格模式**下，JavaScript 允许不声明变量就直接为其赋值，这是因为 JavaScript 解释器能够自动隐式声明变量。隐式声明的变量总是作为全局变量使用。
> 
> ​      在**严格模式**下，变量必须先声明，并且初始化后才能使用。
> 
> ​      "use strict";
> ​      x = 3.14;       // 报错 (x 未定义)

#### 6.4 变量的命名规范

+ `关键字:`是指JS本身已经使用了的单词，不能再用它们充当变量名、方法名
  
  break、case、catch、contine、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、varr、void、while、with等

+ `保留字:`预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。
  
  boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile等

+ `标识符:`就是指开发人员为变量、属性、函数、参数取的名字。 **标识符不能是关键字或保留字。**
- <font color='red'>变量名称的命名规则：</font>
  
  - 名称可包含字母、数字、下划线和美元符号$
  - 名称必须以字母, $ 和 下划线_ 开头 (不能以数字开头)
  - 后面可以跟字母 下划线_ $和数字
  - 名称对大小写敏感（Animal和 animal 是不同的变量）,即严格区分大小写
  - 保留字（比如 JavaScript 的关键词）无法用作变量名称

- 命名规范
  
  标识符命名要做到顾名思义。
  
  > 起一个有意义的名字，尽量做到看一眼就知道是什么意思(提高代码可 读性) 比如: 名字 就定义为 name , 定义学生 用 student
  
  ```js
  a = 18;             # bad
  age = 18;           # good
  ```
  
  遵守一定的命名规范。
  
  - 驼峰命名法，又分为大驼峰命名法和小驼峰命名法
  
  ![16](./img/16.png)
  
  - 小驼峰式命名法（lower camel case）： 第一个单词以小写字母开始；第二个单词的首字母大写
    
    > 例如：firstName，lastName
  
  - 大驼峰式命名法（upper camel case）： 每一个单字的首字母都采用大写字母，
    
    > 例如：FirstName、LastName

#### 6.5 赋值变量

+ 使用等号`=`运算符可以为变量赋值，等号左侧为变量，右侧为被赋的值。

```html
<!DOCTYPE html>
<html>
    <head>
      这是一个赋值变量的一个案例
    </head>
    <body>
        <script>
            var name = 'Barry';
            console.log(name);
        </script>
    </body>
</html> 
```

#### 6.6 变量提升

JavaScript 在预编译期会先预处理声明的变量

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset='utf-8'>
    </head>
    <body>
        <script>
            console.log(a_name); // undefined
            a_name = 'Barry'
            console.log(a_name); // Barry
            var a_name;
        </script>
    </body>
</html> 
```

<font color='blue'>注意：声明变量放在最后，赋值操作放在前面。由于 JavaScript 在预编译期已经对变量声明语句进行了预解析，所以第一行代码读取变量值时不会抛出异常，而是返回未初始化的值 undefined。第三行代码是在赋值操作之后读取，故显示为Barry。JavaScript 引擎的解析方式是：先解析代码，获取所有被声明的变量，然后再一行一行地运行。 这样，所有声明的变量都会被提升到代码的头部，这就叫作变量提升。</font>

#### 6.7 案例练习

- 练习1：看看结果是什么？
  
  ```html
  <!DOCTYPE html>
  <html>
      <head>
          <meta charset='utf-8'>
      </head>
      <body>
          <script>
              console.log(a);
              var a = 100;
              console.log(a);
          </script>
      </body>
  </html> 
  ```

- 练习2：将两个变量a,b的值交换，var a = 1; var b = 2;
  
  方案1：
  
  ```html
  <!DOCTYPE html>
  <html>
      <head>
          <meta charset='utf-8'>
      </head>
      <body>
          <script>
              var a = 1,
                  b = 2,
                  tmp;
              tmp = a;
              a = b;
              b = tmp;
              console.log(a);
              console.log(b);
          </script>
      </body>
  </html> 
  ```
  
  方案2：
  
  ```html
  <!DOCTYPE html>
  <html>
      <head>
          <meta charset='utf-8'>
      </head>
      <body>
          <script>
              var a = 1,
                  b = 2;
              a = a + b;
              b = a - b;
              a = a - b;
              console.log(a);
              console.log(b);
          </script>
      </body>
  </html> 
  ```

### 7. JavaScript的变量类型

JavaScript的数据类型分为两种：基本数据类型和引用数据类型

- **基本数据类型**：
  
  - 字符串（String）
  
  - 数字(Number)
  
  - 布尔(Boolean)
  
  - 未定义（Undefined）
  
  - 空（Null）
  
  - Symbol
  
  > 注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值

- **引用数据类型**：
  
  - 数组(Array)
  
  - 函数(Function)
  
  - 对象(Object)
1. 字符串
   
   字符串可以是引号中的任意文本。您可以使用单引号或双引号：
   
   - `var name = "张三"`
   - `var name = '李四'`
   
   特殊书写方式-俗称:屌丝写法
   
   + `var name = '王二"麻子"'`
   + `var name = "你是'小淘气'"`
   + 不允许`var name = '田七"`
   + 不允许`var name = "田七'`
   + 不允许`var name = ""田"七"`
   + 不允许`var name = ''田'七'`
   + 如果某屌丝就想写，可以使用转义字符`var name = "\"田\"七"`
   
   思考：两次结果一致吗？
   
   ```js
   var name = "谢广坤"；
   alert(name)；
   alert('name')；
   ```

2. 数字
   
   JavaScript 只有一种数字类型。数字可以带小数点，也可以不带：
   
   + 整数：
     + `var a = 1;`
   + 浮点数：
     + `var a = 1.2;`
   
   科学计数法
   
   + `var a = 123e5; var b = Number.MAX_VALUE`
   + `var a = 123e-5; var b = Number.MIN_VALUE`

3. 布尔
   
   布尔（逻辑）只能有两个值：true 或 false。
   
   + `var b = true`
   + `var b = false`

4. Undefined
   
   当声明变量  但是没有初始化变量的时候 就会产生undefined
   
   + `var u；`

5. null
   
    空  一般用于删除对象
   
   + `var n = null`
   + 类型是object，用来表示一个空的对象

### 8. JavaScript的变量类型高级

1. 字符串
   
   JavaScript字符串(String)就是由零个或多个**Unicode字符**组成的字符序列。零个字符表示空字符串。
   
   + 字符串字面量/字符串直接量
   + 字符串必须包含在单引号或双引号中
   + 如果字符串包含在双引号中,则字符串内可以包含单引号;反之,也可以在单引号中包含双引号
   + 在ECMAScript 3中,字符串必须在一行内表示,换行表示是不允许的，如果要换行显示字符串,可以在字符串中添加换行符(\n)
   + 在ECMAScript 5中,字符串允许多行表示.实现方法:在换行结尾处添加反斜杠(\\).反斜杠和换行符不作为字符串直接量的内容
   + 在字符串中插入特殊字符,需要使用转义字符\,如单引号,双引号等
   + 字符串中每个字符都有固定的位置.第1个字符的下标位置为0,第2个字符的下标位置为1...···以此类推,最后一个字符的下标位置是字符串长度减1

```html
      <!DOCTYPE html>
     <html>
         <head>
    </head>
     </head>
     <body>
         <script>
             var str = '사랑해요 사랑해요 愛してるchit pa deMain tumse pyar karta hoon';
             console.log(str);

             // 可以直接定义一个空的字符串
          var str1 = '';
             console.log(str1);

             // 字符串换行---打印时候换行
          var str2 = '一人我饮酒醉\n醉把那佳人成双对';
             console.log(str2);

             // 字符串换行---在编写的时候 允许换行
          // 使用的是\ 但是\不会跟随输出
             var str3 = '两眼是独相随\
             只求他日能双归';
             console.log(str3);

             var str = 'hello ni hao';

             // (1)获取的字符串的长度
          // 长度指的是 这个字符串一共有多少个字符
             // console.log(str.length);
              // (2)通过[] 里面添加对应的位置 就可以获取对应的数据
              // 位置是从0开始的
              // console.log(str[0]);
              // console.log(str[1]);
              // console.log(str[2]);
              // console.log(str[3]);
              // console.log(str[4]);

              // （3）获取最后的那个字符
           console.log(str[9]);
              console.log(str.length);
              console.log(str[str.length - 1]);
          </script>
      </body>
  </html> 
```

+ 转义字符
  
  + 转义字符是字符的一种间接表示方式。在特殊语境中,无法直接使用字符自身
    
    ```js
    var str = "请看\"这个是一个双引号";
    console.log(str);
    ```
  
  + 如果在一个正常字符前添加反斜杠,JavaScript会忽略该反斜杠
    
    ```html
    <!DOCTYPE html>
    <html>
        <head>
            <meta charset='utf-8'>
        </head>
        <body>
            <script>
                // 在某些特殊的语境中 无法使用的字符 我们就需要转义来将
                // 进行输出
                var str = '\'哈哈哈';
                console.log(str);
    
                // 在正常的字符串里面数据的前面添加一个转义字符 则会被忽略
                var str1 = '今天\你过的好吗？';
                console.log(str1);
    
                // 如果我要想一个反斜线 怎么做？
                var str2 = '今天\\你过的好吗？';
                console.log(str2);
            </script>
        </body>
    </html> 
    ```

+ 字符串操作
  
  + 借助String类型的原型方法,可以灵活操作字符串（后面各章节中详细介绍）
  
  + 在JavaScript中,可以使用加号(+)运算符连接两个字符串
  
  + 使用字符串的length属性获取字符串的字符个数(长度）
  
  + 在ES5中，字符串可以作为只读数组使用，可以通过中括号运算符添加下标访问某一个值。下标从0开始，最大位置的下标是length-1
    
    ```html
    <!DOCTYPE html>
    <html>
        <head>
            <meta charset='utf-8'>
        </head>
        <body>
            <script>
                var str = 'hello';
    
                // string
                // 字符串 + 字符串 ===》将字符串链接在一起了
                console.log(str + 'kanghui');
                // number
                // 字符串 + 数字  ===》将数字和字符串链接在一起了
                console.log(str + 5);
                console.log(str + 1.5);
                // boolean
                // 字符串 + boolean ===》将true和字符串链接在一起了
                console.log(str + true);
                console.log(str + false);
                // undefined
                // 字符串 + undefined ===》将undefined和字符串在一起了
                console.log(str + undefined);
                // null
                console.log(str + null);
    
                // 综上所述：
                // 在+号的两端 只要有一端是字符串 那么结果就是字符串
                // 结果是拼接的结果
            </script>
        </body>
    </html> 
    ```

+ String()方法
  
  String()方法是可以将其他类型转换成字符串类型
  
  应用场景：后端给你的数据 不是你想要的字符串 而是其他的数据类型, 那么此时 我们就可以通过String方法来转换其数据类型
  
  ```html
  <!DOCTYPE html>
  <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Title</title>
            </head>
            <body>
                <script>
                    // 强制类型转换
  
              // string
              // var str = 'abcd';
              // 判断数据的数据类型
              // console.log(typeof str);
              // 将str强制类型转换为字符串
              // var str_string = String(str);
              // console.log(typeof str_string);
  
              // number
               // var str2 = 123;
               // console.log(typeof str2);
               // var str2_string = String(str2);
               // console.log(typeof str2_string);
  
              // boolean
               // var str3 = true;
               // console.log(typeof str3);
  
               // var str3_string = String(str3);
               // console.log(str3_string);
               // console.log(typeof str3_string);
  
               // undefined
               // var str4 = undefined;
               // console.log(typeof str4);
  
               // var str4_string = String(str4);
               // console.log(typeof str4_string);
  
               // null  null就是null的类型 但是在判断null的时候，显示的是object类型
               var str5 = null;
               console.log(typeof str5);// object类型
  
               var str5_string = String(str5);
               console.log(typeof str5_string);
               // 总结：可以使用方法String() 来将任何的数据转换为字符串类型
                 </script>
             </body>
   </html>             
  ```

+ toString()方法
  
  - <font color='blue'>null和undefined没有toString方法  所以它们两使用这个方法不能转换为字符串，会报错. ( 相比之下，开发中推荐使用String(), 该方法也可以转换null和undefined )</font>
  + 我们的代码中有+（加号）运算符的情况下，它在这种情况下（字符串 + 其它什么东西），会调用toString()方法，将其它类型的东西转化为字符串，再和原始字符串拼接成一个字符串
  + 除了null和undefined之外，其他的类型(数值、布尔、字符串)都有toString()方法，它返回相应的值。
  + 字符串表现(并不修改原变量)。
  + 每个对象都有一个toString()方法。
  + 当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用toString()方法
  
  ```html
  <!DOCTYPE html>
  <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Title</title>
        </head>
        <body>
            <script>
                // 思考：为什么加号的两端 只要有一端是字符串 那么结果就是
              // 字符串呢?
              // 如果在加号的两端一端有字符串了 那么另一端的数据就会调用
              // toString 然后再进行拼接
              // console.log('a' + 1);
              // 1.toString() ===> '1'  再将'a' + '1' ==>'a1'
  
              // 除了null和undefined之外，其他的数据类型的数据 都有toString方法
              // 返回的是相应的值
  
              // toString本身的意义也是将对相应的数据转换为字符串类型
  
              // string
              // console.log('a'.toString());
  
              // number
              // var a = 1;
              // 判断了a.toString()的值的类型
              // console.log(typeof a.toString());
  
              // boolean
              // var a = true;
              // console.log(typeof a.toString());
  
              // undefined
              // undefined没有toString这个方法
              // console.log(undefined.toString());
  
              // null
              // null没有toString方法
              console.log(null.toString());
            </script>
        </body>
  </html>
  ```
2. 数字
   
   数字（Number）也称为数值或者数
   
   当数字直接出现在程序中时，被称为数值直接量。在 JavaScript程序中，直接输入的任何数字都被视为数值直接量。
   
   > JavaScript 中的所有数字都是以 64 位浮点数形式存储，包括整数。例如，2 与 2.0 是同一个数。
   
   + 浮点数溢出
     
     执行数值计算时，要防止浮点数溢出。例如，0.1+0.2 并不等于 0.3。
     
     `num = 0.1+0.2;   //0.30000000000000004`
     
     这是因为 JavaScript 遵循二进制浮点数算术标准（IEEE 754）而导致的问题。这个标准适合很多应用，但它违背了数字基本常识。
     
     解决方法：浮点数中的整数运算是精确的，所以小数表现出来的问题可以通过指定精度来避免。例如，针对上面的相加可以这样进行处理。
     
     `a = (1+2)/10;   //0.3`
     
     这种处理经常在货币计算中用到。例如，元可以通过乘以 100 而转成分，然后就可以准确地将每项相加，求和后的结果可以除以 100 再转换回来
   
   + 特殊数值
     
     ![08](.\img\08.png)
     
     + Infinity (开发中几乎用不上Infinity)
       
       + 计算超出范围会得到无穷大(infinity)或者无穷小(-infinity)
       
       + <font color='blue'>分母为0会构成无穷大Infinity 或负无穷大-Infinity</font>
       
       + 关于Infinity和非Infinity的运算， 加减乘除一个数字都是Infinity
       
       + Infinity和Infinity计算，加法乘法为Infinity，减法和除法为NaN
       
       + Infinity和自身相等 其他比较正常
         
         ```html
         <!DOCTYPE html>
         <html lang="en">
                 <head>
                     <meta charset="UTF-8">
                     <title>Title</title>
                 </head>
                 <body>
                     <script>
                         // 分母为0会构成无穷大Infinity 或负无穷大-Infinity
                         var num6 = 5/0;
                         console.log(num6);//Infinity
         
                         var num7 = -5/0;
                         console.log(num7);//-Infinity
         
                         console.log(typeof (Infinity));//无穷大和无穷小都是属于number类型
         
                         // 关于Infinity的运算， 无法计算 加减乘除一个数字都是Infinity，Infinity和Infinity计算，加法乘法为Infinity，其他为NaN
                         console.log(Infinity + 1);//Infinity
                         console.log(Infinity - 1);//Infinity
                         console.log(Infinity - 1000000000000000000000);//Infinity
                         console.log(Infinity - Infinity);//NaN
                         console.log(Infinity * Infinity);//Infinity
                         console.log(Infinity + Infinity);//Infinity
                         console.log(Infinity / Infinity);//NaN
         
                         //Infinity和自身相等  其他比较正常
                         console.log(Infinity > 1);//true
                         console.log(Infinity < 1);//false
                         console.log(Infinity == 1);//false
                         console.log(Infinity > Infinity);//false
                         console.log(Infinity == Infinity);//true
                         console.log(Infinity < Infinity);//false
                         console.log(Infinity > -Infinity);//true
                     </script>
                 </body>
         </html>
         ```
     
     + NaN
       
       + NaN,即非数值(Not a Number)是一个特殊的数值
       
       + 这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)
       
       + <font color='blue'>NaN特点：无论和谁比较都是fasle 无论和谁计算都是NaN（除了字符串的加法）</font>
         
         - <font color='blue'>任何和NaN的计算结果都是NaN（字符串加法除外）</font>
         
         - <font color='blue'>任何和NaN的比较结果都是false</font>
         
         ```html
         <!DOCTYPE html>
         <html lang="en">
               <head>
                   <meta charset="UTF-8">
                   <title>Title</title>
               </head>
               <body>
                   <script>
                       var num8 = "红浪漫"-1;
                       console.log(num8)//NaN
         
                       // NaN not a number  不是一个数值
         
                     var str = '红浪漫';
                     // 一个字符串是不可以减一  理论行不通
                     // js怕报错 所以返回了一个NaN
                     var n = str - 1;
                     // console.log(n); //NaN
         
                     // 计算
                     // 数值和NaN计算 除了+字符串之外 其余的全是NaN
                     // +
                     // console.log(n + 'abc'); //NaNabc
                     // console.log(n + 1);
                     // console.log(n + true);
                     // console.log(n + undefined);
                     // console.log(n + null);
                     // -
                     // console.log(n - 'abc');
                     // console.log(n - 1);
                     // console.log(n - true);
                     // console.log(n - undefined);
                     // console.log(n - null);
                     // *
                     // console.log(n * 'abc');
                     // console.log(n * 1);
                     // console.log(n * true);
                     // console.log(n * undefined);
                     // console.log(n * null);
                     // /
                     // console.log(n / 'abc');
                     // console.log(n / 1);
                     // console.log(n / true);
                     // console.log(n / undefined);
                     // console.log(n / null);
                     // 比较
                          // 任何和NAN的比较的结果都是false
                          // string
                          console.log(n > 'abc');
                          console.log(n < 'abc');
                          // number
                          console.log(n > 1);
                          console.log(n < 1);
                          // boolean
                          console.log(n > true);
                          console.log(n < true);
                          console.log(n < false);
                          console.log(n > false);
                          // undefined
                          console.log(n > undefined);
                          console.log(n < undefined);
                          // null
                          console.log(n > null);
                          console.log(n < null);
         
                          // 总结：
                          // 任何和NaN的计算结果都是NaN（字符串加法除外）
                          // 任何和NaN的比较结果都是false
                        </script>
                    </body>
              </html>
         ```
         
         + isNaN：
           
           isNaN方法检测一个值是不是非纯数字 , 如果非纯数字就返回true 如果是纯数字就返回false
         
         ```html
         <!DOCTYPE html>
              <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <title>Title</title>
                    </head>
                    <body>
                        <script>
                                document.write(isNaN(123));
                                document.write(isNaN(-1.23));
                                document.write(isNaN(5-2));
                                document.write(isNaN(0));
                                document.write(isNaN("Hello"));
                                document.write(isNaN("2005/12/12"));
         
                                // 特殊情况
                               console.log(isNaN('2')); // false, 有隐式转换，把字符串的2转为number类型的2
                               console.log(isNaN(true));// false，有隐式转换，把boolean的true转为number类型的1
                               console.log(isNaN(false));// false，有隐式转换，把boolean的false转为number类型的0
                        </script>
                    </body>
              </html>
         ```
         
         + 最大值最小值：
           
           在js中数字也是有最大值和最小值的支持的，如果超过最大值或最小值，就可能计算有误
         
         ```js
         // 在js中数字也是有最大值和最小值的支持的，如果超过最大值或最小值，就可能计算有误
            console.log(Number.MIN_VALUE);//5e-324  支持数字的最小值
            console.log(Number.MAX_VALUE);//1.7976931348623157e+308 支持数字的最大值
         ```
         
         + 正无穷负无穷
         
         ```html
         <!DOCTYPE html>
            <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>Title</title>
                </head>
                <body>
                    <script>
                        console.log(Number.POSITIVE_INFINITY);
                        console.log(Number.NEGATIVE_INFINITY);
                    </script>
                </body>
            </html>
         ```

3. 布尔boolean
   
   布尔类型仅包含两个固定的值：`true`和`false`。其中`true`代表真，`false`代表假。
   
   在一些判断等操作中，需要使用布尔值
   
   ```html
   <!DOCTYPE html>
   <html lang="en">
         <head>
             <meta charset="UTF-8">
             <title>Title</title>
         </head>
         <body>
             <script>
                 // 布尔：强制类型转换
               // var a = true;
               // var b = false;
               // console.log(a);
               // console.log(b);
   
               // string
               // Boolean（字符串）的时候 判断字符串里面是否有内容
               // 如果有内容就是true 如果没有内容就是false. 只要字符串有内容 哪怕是空格都是true
               // console.log(Boolean('abcd'));//true
               // console.log(Boolean('')); //false, 空字符串就是没有内容
               // console.log(Boolean('       ')); //true, 内容是空格
   
               // number
               // Boolean(数值) 只要有数值都是true  但是0除外
               // console.log(Boolean(1));
               // console.log(Boolean(-1));
               // console.log(Boolean(1.1));
               // console.log(Boolean(-1.1));
               // console.log(Boolean(0));//false
   
               // console.log(Boolean(Infinity));
               // console.log(Boolean(-Infinity));
               // console.log(Boolean(NaN)); //false
   
               // boolean
               // console.log(Boolean(true));
               // console.log(Boolean(false));//false
               // undefined
               console.log(Boolean(undefined));//false
               // null 
               console.log(Boolean(null));//false
   
               // 哪几种情况是false的时候 千万要注意
               // Boolean强制类型转换只有以下6种情况是false：
               // （1）空串(即空字符串)
               // （2）0   
               // （3）NaN
               // （4）false
               // （5）undefined
               // （6）null
             </script>
         </body>
   </html>
   ```
   
   <font color='blue'>Boolean强制类型转换只有以下6种情况是false：</font>
   
   1. <font color='blue'>空串(即空字符串)，注意空串里有空格会转换为true</font>
   
   2. <font color='blue'>0</font>
   
   3. <font color='blue'>Nan</font>
   
   4. <font color='blue'>false</font>
   
   5. <font color='blue'>undefined</font>
   
   6. <font color='blue'>null</font>

4. Undefined
   
   当一个变量被声明了，但没有赋值时，就等于undefined
   
   <font color='blue'> undefined + 除了字符串之外的任意的数 都是NaN</font>
   
   ```js
   //打印a的时候，找到a了 但是找不到a的值，所以返回一个undefined
   var a;
   console.log(a);
   console.log(a+1);//undefined+1  计算不了 结果是NaN
   
   //不声明b，直接使用b，js直接报错  ReferenceError(引用错误)： b is not defined
   //说明完全没有找到b这个变量 代码报错停止运行
   console.log(b)
   ```

5. null
   
   - null 类型是第二个只有一个值的数据类型(另一个是undefined)，这个特殊的值是 null。
   - 从逻辑角度来看，null 值表示一个空对象指针，这也正是<font color='blue'>使用 typeof 操作符检测null时会返回"object"</font>的原因

6. 扩展：

```js
  1. Undefined派生自Null，两者都是表示空缺值，转换成布尔值都是假值，可以相等
  2. 但是Undefined和Null属于两种不同的类型
  3. Undefined隐含着意外的空值，而Null隐含着意料之中的空值。因此设置一个变量、参数为空的时候，建议使用null而不是undefined

  console.log(null == undefined);//true，这个只能记住，无道理可言
   console.log(null === undefined) //false，因为类型不同
```

### 9. JavaScript判断数据类型

> 友情提示:
> 
> 基本数据类型：String、Number、Boolean、Undefined、Null、Symbol
> 
> 引用数据类型 ：Object、 数组、 函数

1. typeof 主要用来判断基本数据类型
   
   typeof 可以识别出基本类型String，、Number、Boolean、Undefined，Symbol，<font color='blue'>但是不能识别null</font>。
   
   typeof 不能识别引用数据类型，会把null、array、object统一归为object类型, <font color='blue'>但是可以识别出function。</font>
   
   所以 typeof 可以用来识别一些基本类型. 实际的企业级开发中  基本数据类型一般都用typeof来识别
   
   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <title>Title</title>
   </head>
   <body>
       <script>
           var bool = true;
           var num = 1;
           var str = 'abc';
           var und= undefined;
           var nul = null;
           var s1 = Symbol();
   
           console.log(typeof bool); //boolean
           console.log(typeof num);//number
           console.log(typeof str);//string
           console.log(typeof und);//undefined
           console.log(typeof nul);//object
           console.log(typeof s1); //symbol
   
          function f1(){}
          console.log(typeof f1); //function
       </script>
   </body>
   </html>
   ```
   
   <font color='blue'>扩展: typeof结果的类型是什么？是 string</font>

2. instanceof 主要用来判断引用数据类型
   
   instanceof不能识别出基本的数据类型 String，、Number、Boolean、Undefined、Null、Symbol
   
   但是可以检测出引用类型，如array、object、function
   
   一般企业级开发 使用instanceof来判断引用数据类型
   
   ```html
    <!DOCTYPE html>
      <html lang="en">
           <head>
                  <meta charset="UTF-8">
               <title>Title</title>
              </head>
              <body>
                  <script>
                      var bool = true;
                      var num = 1;
                      var str = 'abc';
                      var und= undefined;
                      var nul = null;
                      var s1 = Symbol();
                  console.log(bool instanceof Boolean);// false
                  console.log(num instanceof Number);// false
                  console.log(str instanceof String);// false
                  console.log(und instanceof Object);// false
                  console.log(nul instanceof Object);// false
                  console.log(s1 instanceof Symbol);// false
   
                  // 判断引用数据类型
                  console.log([] instanceof Array); //true
                  console.log({} instanceof Object);//true
   
                 function f1(){}
                 console.log(f1 instanceof Function);//true
              </script>
          </body>
   </html>
   ```

3. constructor()
   
   null、undefined没有construstor方法，因此constructor不能判断undefined和null。
   
   <font color='blue'>开发中不使用这个方法进行判断</font>
   
   ```html
    <!DOCTYPE html>
      <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Title</title>
            </head>
            <body>
                <script>
                    var bool = true;
                    var num = 1;
                    var str = 'abc';
                    var und= undefined;
                    var nul = null;
                    var s1 = Symbol();
   
                    console.log(bool.constructor === Boolean);// true
                    console.log(num.constructor === Number);// true
                    console.log(str.constructor === String);// true
                    console.log(s1.constructor === Symbol);//true
                </script>
            </body>
      </html>
   ```

4. toString()
   
   此方法可以相对较全的判断js的数据类型。但<font color='blue'>不推荐</font>使用这个方法做判断，太麻烦，性能低
   
   ```html
   <!DOCTYPE html>
   <html lang="en">
         <head>
             <meta charset="UTF-8">
             <title>Title</title>
         </head>
         <body>
             <script>
                 var bool = true;
                 var num = 1;
                 var str = 'abc';
                 var und= undefined;
                 var nul = null;
                 var s1 = Symbol();
   
                 console.log(Object.prototype.toString.call(bool));//[object Boolean]
                 console.log(Object.prototype.toString.call(num));//[object Number]
                 console.log(Object.prototype.toString.call(str));//[object String]
                 console.log(Object.prototype.toString.call(und));//[object Undefined]
                 console.log(Object.prototype.toString.call(nul));//[object Null]
                 console.log(Object.prototype.toString.call(s1)); //[object Symbol]
             </script>
         </body>
   </html>
   ```

5. 总结：至于在项目中使用哪个判断，还是要看使用场景，具体的选择，<font color='red'>一般基本的类型可以选择typeof，引用类型可以使用instanceof。</font>

### 10. JavaScript数据类型转换

1. Number方法
   
   Number()方法 将其他类型转换成number类型 Number方法会返回一个转换后的值
   
   ```html
   <!DOCTYPE html>
   <html lang="en">
         <head>
             <meta charset="UTF-8">
             <title>Title</title>
         </head>
         <body>
             <script>
                 // string
               // console.log(Number('123'));
               // console.log(Number('-123'));
               // console.log(Number('1.23'));
               // console.log(Number('-1.23'));
               // console.log(Number('0'));    ---->0
   
               // 空字符串 Number转换之后是0
               // console.log(Number(''));     ----->0
               // 如果字符串中都是空格的话 那么结果就是0
               // console.log(Number('         '));----->0
               // NaN
               // console.log(Number('a'));
               // console.log(Number('李'));
               // console.log(Number('1a'));
   
               // number
               // console.log(Number(1));
               // console.log(Number(-1));
               // console.log(Number(1.1));
               // console.log(Number(-1.1));
               // console.log(Number(0));      ------>0
               // console.log(Number(NaN));
               console.log(Number(Infinity));
               // console.log(Number(Number.MAX_VALUE));
               // console.log(Number(Math.PI));
   
               // boolean
               // console.log(Number(true)); // 1
               // console.log(Number(false));// 0  ------>0
   
               // undefined  
               console.log(Number(undefined));//NaN
   
               // null
               console.log(Number(null));//0
             </script>
         </body>
   </html>
   ```

2. parseInt
   
   parseInt是一个全局方法,它可以把值转换为整数
   
   - 第1步,先解析位置0处的字符,如果不是有效数字,则直接返回 NaN.
   - 第2步,如果位置0处的字符是数字,或者可以转换为有效数字,则继续解析位置1处的字符,如果不是有效数字,则直接返回位置0处的有效数字。
   - 第3步,以此类推,按从左到右的顺序,逐个分析每个字符,直到发现非数字字符为止。
   - 第4步,parseInt()将把前面分析合法的数字字符全部转换为数值并返回。
   - <font color='blue'>如果是空的字符串或者字符串中只有空格 则返回NaN</font>
   
   ```html
   <!DOCTYPE html>
   <html lang="en">
       <head>
           <meta charset="UTF-8">
           <title>Title</title>
       </head>
       <body>
           <script>
               // string
               console.log(parseInt('1'));
               console.log(parseInt('-1'));
               // parseInt解析整数  
               // 解析到第一个非数字的字符就停止
               console.log(parseInt('1.2'));
               console.log(parseInt('-1.2'));
               console.log(parseInt('0'));
   
               console.log(parseInt('1a2b3c'));
               console.log(parseInt('123a'));
               console.log(parseInt('a123'));
   
               // number
               console.log(parseInt(1));
               console.log(parseInt(-1));
               console.log(parseInt(1.2));
               console.log(parseInt(-1.2));
               console.log(parseInt(0));
               console.log(parseInt(NaN));
               console.log(parseInt(Infinity));//NaN，注意结果和parseFloat(Infinity)不同
   
               // boolean
               console.log(parseInt(true));//NaN
               console.log(parseInt(false));//NaN
   
               // undefined
               console.log(parseInt(undefined));//NaN
   
               // null
               console.log(parseInt(null));//NaN
           </script>
       </body>
   </html>
   ```

3. parseFloat()也是一个全局方法，它可以把值转换成浮点数，<font color='blue'>即它能够识别第一个出现的小数点，而第二个小数点视为非法。</font>解析过程和parseInt相同。
   
   ```html
   <!DOCTYPE html>
   <html lang="en">
       <head>
           <meta charset="UTF-8">
           <title>Title</title>
       </head>
       <body>
           <script>
               // string
               console.log(parseFloat('1'));
               console.log(parseFloat('-1'));
               console.log(parseFloat('1.2'));
               console.log(parseFloat('-1.2'));
               console.log(parseFloat('0'));
   
               console.log(parseFloat('1.2.3.4'));
               console.log(parseFloat('1.2a.3'));
               console.log(parseFloat('a1.2'));
   
               // number
               console.log(parseFloat(1));
               console.log(parseFloat(-1));
               console.log(parseFloat(1.3));
               console.log(parseFloat(-1.3));
               console.log(parseFloat(0));
               console.log(parseFloat(0.0));
   
               console.log(parseFloat(NaN));//NaN
               console.log(parseFloat(Infinity)); //Infinity,注意结果和parseInt(Infinity)不同
   
               // boolean
               console.log(parseFloat(true));//NaN
               console.log(parseFloat(false));//NaN
   
               // undefined
               console.log(parseFloat(undefined));//NaN
   
               // null
               console.log(parseFloat(null));//NaN
           </script>
       </body>
   </html>
   ```

4. 运算符转换
   
   如果变量乘以1，则变量会被JS自动转换成数值，如果无法转换成合法数值，则返回NaN
   
   ```html
   <!DOCTYPE html>
   <html lang="en">
       <head>
           <meta charset="UTF-8">
           <title>Title</title>
       </head>
       <body>
           <script>
               /*如果说变量乘以1  变量就会被自动隐式转换为数字类型，如果转不了就变成NaN*/
               var a = "1";
               console.log(a * 1);//number类型的  1
               var b = "1a";
               console.log(b * 1);//NaN
   
               /*减法也可以*/
               var c = "1";
               console.log(c - 0);//number类型的  1
               var d = "1a";
               console.log(d - 0);//NaN
   
               /*除1也可以*/
               var e = "1";
               console.log(e / 1);//number类型的  1
               var f = "1a";
               console.log(f / 1);//NaN
           </script>
       </body>
   </html>
   ```

### 11. JavaScript运算符

> JS中为我们定义了一套对数据进行运算的运算符,共定义了47个运算符。

#### 11.1  算术运算符

![09](.\img\09.png)

说明：

+ 递增(++)和递减(--)运算就是通过不断地加1或减1,然后把结果赋值给左侧，以实现改变自身结果的一种简洁方法

+ 递增和递减在运算之前都会试图转换值为数值类型,如果失败则返回 NaN。

+ 根据位置不同,可以分为4种运算方式
  
  - 前置递增(++n):先加一,再赋值
  - 后置递增(n++):先赋值,再加一
  - 前置递减(--n):先减一,再赋值
  - 后置递减(n--):先赋值,再减一

+ 一元运算符：一个操作数 ++ --
  
  前++(--)或者后++(--)都是自身+1(-1)再给自身赋值
  
  对于a，前++(--)和后++(--)都是自身+1(-1)再赋值给自己
  
  对于b，前++(--),a先+1(-1)赋值给自己后再参与后面的计算。后++(--)，要看后面的算式是否再次用到a，如果用到，才把之前的后++(--)算上。

```html
<!DOCTYPE html>
<html lang="en">
      <head>
          <meta charset="UTF-8">
          <title>Title</title>
      </head>
      <body>
          <script>
              // 无论是  ++a；  还是 a++；  都是让 a每次加1，如果两个代码都是独立运行，那么两个代码没有区别
              var a = 1;
              a ++;//a++是让a  每次加1
              a ++;//a++是让a  每次加1
              a ++;//a++是让a  每次加1
              console.log(a);

              var b = 1;
              ++ b;//让b每次加1
              ++ b;//让b每次加1
              ++ b;//让b每次加1
              ++ b;//让b每次加1
              console.log(b);

              //c++不是单独运行的时候，也就是有赋值操作的时候，那么是先执行赋值，然后再去加1
              //c++ 就是先赋值 后加1
              var c = 2;
              var d = c ++;
              console.log(c);
              console.log(d);

              //++c  先加一 后赋值
              var c = 2;
              var d = ++ c;
              console.log(c);
              console.log(d);
          </script>
      </body>
</html>
```

练习：

1. ```js
   var a = 1;
   var b = ++a;
   console.log(a);//2
   console.log(b);//2
   ```

2. ```js
   var a = 1;
   var b = a++;
   console.log(a);//2
   console.log(b);//1
   ```

3. ```js
   var a = 1;
   var b = ++a + a;
   console.log(a);//2
   console.log(b);//4
   ```

4. ```js
   var a = 1;
   var b = ++a + ++a + a;
   console.log(a);//3
   console.log(b);//8
   ```

5. ```js
   var a = 1;
   var b = a + ++a + 1 + a + ++a;
   console.log(a); //3
   console.log(b); //9
   ```

6. ```js
   var a = 1;
   var b = a + a + ++a + 1 + a + ++a
   console.log(a);//3
   console.log(b);//10
   ```

7. ```js
   var a = 1;
   var b = a++ + 1 + a++;
   console.log(a);//3
   console.log(b);//4
   ```

8. ```js
   var a = 1;
   var b = a++ + a++ + a + 1 + a++ + 1;
   console.log(a);
   console.log(b);
   ```

9. ```js
   var a = 1;
   var b = a++ + ++a + a + a++;
   console.log(a);
   console.log(b);
   ```

10. ```js
    var b = ++a + a++ + a++ + a + ++a + a++ + a;
    console.log(a);
    console.log(b);
    ```

11. ```html
    <!DOCTYPE html>
    <html lang="en">
          <head>
              <meta charset="UTF-8">
              <title>Title</title>
          </head>
          <body>
              <script>
                  var a = 1;
                  b = a++ + (a++) + 1 + (++a) + (a++) + (++a) + a + (++a);
                  console.log(a);
                  console.log(b);
              </script>
          </body>
    </html>
    ```
    
    #### 11.2 赋值运算符

![10](.\img\10.png)

#### 11.3 字符串运算符

结果就是所有内容的拼接

+ 运算符也可用于对字符串进行相加（concatenate，级联）。
  
  ```js
    a = "hello";
    b = "red romance";
    c = a + " " + b; //hello red romance
  ```

+ += 赋值运算符也可用于相加（级联）字符串：
  
  ```js
  a = "ok ";
  a += "three man! go go go"; //ok three man! go go go
  ```

+ 相加两个数字，将返回和，但对一个数字和一个字符串相加将返回一个字符串：
  
  ```js
  x = 7 + 8;
  y = "7" + 8;//78
  z = "Hello" + 7;//Hello7
  ```

#### 11.4 比较运算符

![11](.\img\11.png)

#### 11.5 逻辑运算符

- && 当多个条件时,必须所有条件都是true,整个结果才是true,只要有一个条件时false,整个结果就是false
  
  逻辑与（`&&`）运算符从左到右对操作数求值，遇到第一个false时立即返回；如果所有的操作数都是true，则返回最后一个操作数的值
  
  ```js
  result = "" && "foo"; // 结果被赋值为 ""（空字符串）
  result = 2 && 0; // 结果被赋值为 0
  result = "foo" && 4; // 结果被赋值为 4
  ```

- || 当多个条件时,只要有一个条件是true,整个结果就是true,只有所有条件都是false时,整个结果才是false

- ! 取反

![12](.\img\12.png)

#### 11.6 逗号运算符

逗号运算符是二元运算符，它能够先执行运算符左侧的操作数，然后再执行右侧的操作数，最后返回右侧操作数的值。

```js
var a = 1,b = 2,c = 3,d = 4;
```

等价于

```js
var a = 1;
var b = 2;
var c = 3;
var d = 4;
```

练习：观察结果

```js
a = (b = 1,c = 2);
console.log(a);// 2, 等于最后的那个值
console.log(b);// 1
console.log(c);// 2
```

```js
a = b = 1,c = 2;
console.log(a);  
console.log(b);  
console.log(c);  
```

#### 11.7 特殊情况:比较不同的类型

- 字符串和字符串的比较是按照位置比较的ASCII码
  
  ```js
  console.log('5' > '13') // true, 因为5比13第1位的数字1大
  console.log('abc' > b) // false
  ```

- 如果将字符串string与数字number进行比较，那么在做比较时 JavaScript 会把字符串string隐式转换为number数值。空字符串将被转换为 0。
  
  非数值字符串将被转换为始终为 false 的 NaN (<font color='blue'>因为任何和 NaN 比较的结果都是 false</font>)。

![13](.\img\13.png)

<font color='red'>总结：除了string 和 string 的比较是按照ascii 码来比较的，其余无论什么数据类型都是按照 number 转换之后的数值结果来比较的 </font>

#### 11.8 案例练习

+ 优先级

![17](.\img\17.png)

+ 任意数据类型和NaN做数学运算,结果都是NaN,但是注意只要是字符串在和任意数据类型做相加+的运算,都是字符串拼接。
  字符串类型的数据:在进行数学运算(- * / %)时,会先将自身隐式转换(Number)成数值类型再进行计算
  在进行+操作时,是字符串的拼接
  
  ```js
  console.log('2' - '1')；
  console.log('2' - 1)；
  console.log('2' * 1)；
  console.log('2' / 3)；
  猜测一下取余结果的符号和除数，被除数哪个有关？
  console.log('2' % 3)；
  console.log('2' + '1')；
  console.log('1' + 3)；
  console.log('2' - '嘿嘿')；
  console.log('1' - '2abc')；
  console.log('嘿嘿' + '1a')； 
  console.log('嘿嘿' + NaN)；// 嘿嘿NaN
  console.log('嘿嘿' + 5 * '6')//嘿嘿30
  console.log(('嘿嘿' + 5) * '6')；//NaN 
  ```

+ 布尔类型的数据:在进行数学运算(+ - * / %)时,会先将自身隐式转换(Number)成数值类型再进行计算
  
  ```js
  console.log(true + true); //2
  console.log(true + 5); //6
  console.log(true + '8'); //true8
  console.log(true - '8'); // -7
  console.log(false - 3);//-3
  console.log(false - 3 * '哈哈');//NaN
  ```

+ 未定义类型的数据:在进行数学运算(+ - * / %)时,会先将自身隐式转换(Number)成数值类型再进行计算
  
  ```js
  console.log(undefined + undefined);//NaN
  console.log(undefined + 1);// NaN
  console.log(undefined + '5' + '哈哈');//undefined5哈哈
  ```

+ 空类型的数据:在进行数学运算(+ - * / %)时,会先将自身隐式转换(Number)成数值 类型再进行计算
  
  ```js
  console.log(null + true); //1
  console.log(null + 5);//5
  console.log('null' + (null - 3) + undefined);//null-3undefined
  ```

+ 任意数据类型在进行关系运算时,会先将自身隐式转换(Number)成数值,在进行比较字符串与字符串之间的比较< > <= >=,比较的是ascii码,一位一位的去比
  
  ```js
  console.log(5 > 3); //true
  console.log(5 > '3');//true
  console.log('5' < true);//false
  console.log(5 > '6哈哈');//false
  console.log('a' < 'ab');//true
  console.log('ac' > 'ab');//true
  console.log('ab' < 'bz');//true
  console.log(NaN < NaN)//false
  console.log('100' < 'a');//true, 按照ascii码位置比较，a的ascii码是97
  console.log('5' == 5);//true
  console.log(1 == true);//true
  console.log(1 === true);//false
  console.log(0 == false);//true
  console.log(null < 1);//true
  /* null < 和 null > 比较时JS会把null进行隐式转为数值0 */
  
  //特殊的情况
  console.log(null == 0);//false
  console.log(null == ' ');//false
  console.log(null == '');//false
  console.log(null == false);//false
  /* null== 比较时JS没有对null进行隐式转为数值0，这是非常特殊的一个知识点 */
  console.log(null == undefined);//true
  
  总结：除了判断和null的 == 之外，其余的都会转换为number之后再判断
  1- 字符串和字符串的比较：比较的是ascii码
  2- null == 的判断不会将null转换为number类型
  3- 除了以上1- 2-的情况之外，其余的一概转换为number之后再进行判断
  ```

+ 练习题
  
  ```js
  console.log(undefined + null * '-10' + 100 > 90); // NaN > 90 --> false
  
  console.log(null * undefined + null + '嘿嘿');//NaN嘿嘿
  
  console.log(true + 'undefined' - undefined + '5');//NaN5
  
  console.log((5 + true > true) + 5 > true);//true
  
  console.log(!true - '5' + 8 + parseInt('4嘿嘿'));//0-5+8+4=7
  
  console.log((!false - !null) * parseInt('3.14') + '');//!false=true, !null=!false=true --> true-true=0,最终结果为0
  ```

+ 规则: 数学运算转Number, 字符串与任意类型数据相加都是拼接
  
  ​          关系运算转Number,字符串与字符串转Ascii码
  
  ​          逻辑运算转Boolean
  
  短路表达式:
  
  ​    && 与 如果前面的表达式结果是true,返回的是后面表达式的数据，如果前面的表达式结果是false,直接返回数据
  
  ​    || 或 如果前面的表达式是ture,直接返回数据，如果前面的表达式是false,返回的是后面表达式的数据
  
  ​    !  取反  
  
  ```js
  // 以下练习同时要注意不同运算符的优先级
  console.log(5 > 3 && 5 > 4); //true
  var a = 5 > 3 && 5 > 4 && 5 > 6;
  console.log(a);//false
  console.log(5 > 3 && 5 < 4 && 5 > 6);//false
  console.log(5 > 3 || 5 > 6);//true
  console.log(5 < 3 || 5 < 6 || 5 < 8);//true
  console.log(5 && 8);//会把5和8隐式转换为boolean值，5和8的boolean值都是true, 最终结果是8
  console.log(Boolean(5) && Boolean(8));//true
  console.log(null && '红浪漫');//null
  console.log(5 + 3 && 5 + 4);//9
  console.log(true == 5 > 3);//true
  console.log('' && NaN);// ''隐式转换为false，最终结果就是''
  // 作业
  console.log(' ' && NaN);// ' '里面有空格，隐式转为true, 最终结果为NaN
  console.log('红浪漫' && 10 + false && '张三');// '张三'
  
  console.log(' ' && 10 + '红浪漫' && 5 > null);// 10+ '红浪漫'=10'红浪漫',最终结果为true  
  
  // '红浪漫'无法转换为数值，是NaN,10-NaN=NaN, 除了和字符串相加，NaN无论和谁计算都是NaN
  console.log(' ' && 10 - '红浪漫' && 1.3245644564464 + 2.14335334533553 + 32.433433533535);// NaN
  
  console.log(5 || 3);//5
  
  console.log(' ' || 10 + '红浪漫' || 5 > null);//' '
  
  console.log('' || 10 - '红浪漫' || 5 > null);// true
  
  var b; 
  // 5-NaN || 10*NaN || NaN --> NaN
  console.log(5 - undefined || 10 + undefined * null || 5 * b);//NaN
  
  console.log(!(5 > 3)); //false
  console.log(!5);//false
  console.log(!'哈哈');//false
  console.log(!undefined);//true
  console.log(!5 > 3);//!5=false,false隐式转为数值0，0>3=false, 最终结果是false
  
  console.log(!'' + 5 + !null);//1+5+1=7
  
  //&&的计算优先级高于||
  console.log(5 || 3 && '哈哈');//5
  console.log((5 || 3) && '哈哈');//'哈哈‘
  
  var f;
  console.log(!'红浪漫' + NaN || !10 + null * '5' && '8' * !f);//0
  
  //'红浪漫'-8=NaN, NaN=false, !NaN=true
  console.log(' ' + true && !('红浪漫' - 8) || ' ' - 1 && !undefined + null); //true
  
  console.log(!Number(' ') + true && Boolean('红浪漫') - 8 || ' ' - 1 && !undefined+ !(5+ 3));//-7
  ```
